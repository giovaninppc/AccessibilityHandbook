// swiftlint:disable all
// Generated using SwiftGen — https://github.com/SwiftGen/SwiftGen

import Foundation

// swiftlint:disable superfluous_disable_command file_length implicit_return

// MARK: - Strings

// swiftlint:disable explicit_type_interface function_parameter_count identifier_name line_length
// swiftlint:disable nesting type_body_length type_name vertical_whitespace_opening_braces
internal enum L10n {
  /// Additional cost
  internal static let additionalCost = L10n.tr("Localizable", "additionalCost")
  ///  See more on Apple's documentation for "%@"
  internal static func appleDoc(_ p1: Any) -> String {
    return L10n.tr("Localizable", "appleDoc", String(describing: p1))
  }
  /// Back to Index
  internal static let backToIndex = L10n.tr("Localizable", "backToIndex")
  /// Bold text
  internal static let boldText = L10n.tr("Localizable", "boldText")
  /// Cloud
  internal static let cloud = L10n.tr("Localizable", "cloud")
  /// Color Accessibility Features
  internal static let colorAccessibilityFeatures = L10n.tr("Localizable", "ColorAccessibilityFeatures")
  /// Content Hierarchy
  internal static let contentHiererachy = L10n.tr("Localizable", "ContentHiererachy")
  /// Dedicated page
  internal static let dedicatedPage = L10n.tr("Localizable", "dedicatedPage")
  /// Delete
  internal static let delete = L10n.tr("Localizable", "delete")
  /// Deleted
  internal static let deleted = L10n.tr("Localizable", "deleted")
  /// Dismiss
  internal static let dismiss = L10n.tr("Localizable", "dismiss")
  /// Tap twice to copy
  internal static let doubleTapToCopy = L10n.tr("Localizable", "doubleTapToCopy")
  /// Early access
  internal static let earlyAccess = L10n.tr("Localizable", "earlyAccess")
  /// Edit
  internal static let edit = L10n.tr("Localizable", "edit")
  /// Edited
  internal static let edited = L10n.tr("Localizable", "edited")
  /// Example
  internal static let example = L10n.tr("Localizable", "example")
  /// Examples
  internal static let examples = L10n.tr("Localizable", "examples")
  /// Extra bureaucracy
  internal static let extraBureaucracy = L10n.tr("Localizable", "extraBureaucracy")
  /// Fog
  internal static let fog = L10n.tr("Localizable", "fog")
  /// Free shipping
  internal static let freeShipping = L10n.tr("Localizable", "freeShipping")
  /// Go play it!
  internal static let goPlay = L10n.tr("Localizable", "goPlay")
  /// Handbook
  internal static let handbook = L10n.tr("Localizable", "handbook")
  /// Handle Action
  internal static let handleAction = L10n.tr("Localizable", "handleAction")
  /// Haptic
  internal static let haptic = L10n.tr("Localizable", "haptic")
  /// Haptics
  internal static let haptics = L10n.tr("Localizable", "haptics")
  /// Interaction
  internal static let interactrion = L10n.tr("Localizable", "interactrion")
  /// The accessibility element allows direct touch interaction for VoiceOver users.
  internal static let listOfTraits = L10n.tr("Localizable", "ListOfTraits.")
  /// Modal
  internal static let modal = L10n.tr("Localizable", "modal")
  /// Moon
  internal static let moon = L10n.tr("Localizable", "moon")
  /// More
  internal static let more = L10n.tr("Localizable", "more")
  /// More on the Web
  internal static let moreOnTheWeb = L10n.tr("Localizable", "moreOnTheWeb")
  /// More on Wikipedia
  internal static let moreOnWikipedia = L10n.tr("Localizable", "moreOnWikipedia")
  /// Next page %@
  internal static func nextPage(_ p1: Any) -> String {
    return L10n.tr("Localizable", "nextPage", String(describing: p1))
  }
  /// Open Settings
  internal static let openSettings = L10n.tr("Localizable", "openSettings")
  /// Rain
  internal static let rain = L10n.tr("Localizable", "rain")
  /// Regular text
  internal static let regularText = L10n.tr("Localizable", "regularText")
  /// Select
  internal static let select = L10n.tr("Localizable", "select")
  /// Selected
  internal static let selected = L10n.tr("Localizable", "selected")
  /// Snow
  internal static let snow = L10n.tr("Localizable", "snow")
  /// Sun
  internal static let sun = L10n.tr("Localizable", "sun")
  /// Sunrise
  internal static let sunrise = L10n.tr("Localizable", "sunrise")
  /// SwiftUI
  internal static let swiftUI = L10n.tr("Localizable", "swiftUI")
  /// Accessibility Handbook
  internal static let title = L10n.tr("Localizable", "title")
  /// UIKit
  internal static let uikit = L10n.tr("Localizable", "uikit")
  /// Voice-Over guide
  internal static let vocieOverGuide = L10n.tr("Localizable", "VocieOverGuide")
  /// Voice-Over guide
  internal static let voiceOverGuide = L10n.tr("Localizable", "VoiceOverGuide")
  /// Weather Icons
  internal static let weatherIcons = L10n.tr("Localizable", "weatherIcons")

  internal enum AboutColors {
    /// Some people don't experience them at all!
    internal static let comment1 = L10n.tr("Localizable", "AboutColors.comment1")
    /// I'm over extending myself into physics and biology, but bear with me.
    internal static let comment2 = L10n.tr("Localizable", "AboutColors.comment2")
    /// If you don't have a designer there... Well, I hope this content also helps you understand a little bit more about it!
    internal static let comment3 = L10n.tr("Localizable", "AboutColors.comment3")
    /// Human Interface Guidelines - Colors
    internal static let higColors = L10n.tr("Localizable", "AboutColors.higColors")
    /// Image of pretty colors
    internal static let image = L10n.tr("Localizable", "AboutColors.image")
    /// I like colors.\nBut not everybody experience them in the same way.
    internal static let text1 = L10n.tr("Localizable", "AboutColors.text1")
    /// Colors are how our brains make sense of the light that reach our eyes. We have cells that will interact with different frequencies of light, and their combination will produce what we see.
    internal static let text2 = L10n.tr("Localizable", "AboutColors.text2")
    /// And when building an app, colors are usually something that come before actually programming anything, or during what I like to call 'The design step'.
    internal static let text3 = L10n.tr("Localizable", "AboutColors.text3")
    /// So, if you are working on a team with a Designer, I highly recommend you bring these discussion to them. Understanding more about colors, how they affect the users and what we can consider accessibility while handling colors on our app.
    internal static let text4 = L10n.tr("Localizable", "AboutColors.text4")
    /// About Colors
    internal static let title = L10n.tr("Localizable", "AboutColors.title")
  }

  internal enum AboutTheApp {
    /// About the app
    internal static let title = L10n.tr("Localizable", "AboutTheApp.title")
    internal enum Disclaimer {
      /// And I have sure learned a lot while developing this very own app!
      internal static let comment1 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.comment1")
      /// Check the Collaboration page to see more ways to report issues and to help the app's development!
      internal static let openCollaborationPage = L10n.tr("Localizable", "AboutTheApp.Disclaimer.openCollaborationPage")
      /// This app and it's content is supposed to be a helpful guide, based on real development experiences.
      internal static let text1 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text1")
      /// I do not know EVERYTHING about accessibility, and I'm learning a little bit more every day.
      internal static let text2 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text2")
      /// It may have some mistakes or misconceptions, so please, consider reporting if you find any of those.
      internal static let text3 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text3")
      /// I want it to be a reliable tool that can be cosulted during everyday development.
      internal static let text4 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text4")
      /// Disclaimer
      internal static let title = L10n.tr("Localizable", "AboutTheApp.Disclaimer.title")
    }
    internal enum Game {
      /// The puzzles are not supposed to be hard, thay are just a nice way to practice your accessibility knowledge!
      internal static let comment = L10n.tr("Localizable", "AboutTheApp.Game.comment")
      /// The Handbook was pretty nice and all... but it was a little boring.
      internal static let text1 = L10n.tr("Localizable", "AboutTheApp.Game.text1")
      /// So I tryied to make something that would be nicer to use and to learn,
      internal static let text2 = L10n.tr("Localizable", "AboutTheApp.Game.text2")
      /// And what best way to do that than with a game?
      internal static let text3 = L10n.tr("Localizable", "AboutTheApp.Game.text3")
      /// What about the Game?
      internal static let title = L10n.tr("Localizable", "AboutTheApp.Game.title")
    }
    internal enum History {
      /// The Accessibility Handbook started as an idea with some colleagues and friends, aiming to be an easy way to learn more about iOS accessibility features.
      internal static let text1 = L10n.tr("Localizable", "AboutTheApp.History.text1")
      /// At the time we started working on it, but we never got to finish or publish the Handbook. So, a while later, I took what I learned and decided to bring it into the world! Rewriting the contents, adding UIKit and SwiftUI versions to make something really fresh and nice.
      internal static let text2 = L10n.tr("Localizable", "AboutTheApp.History.text2")
      /// I always thought the information about accessibility was always there, but you had to know what to look for.
      internal static let text3 = L10n.tr("Localizable", "AboutTheApp.History.text3")
      /// That's where this handbook comes, it's something that can be collaborative, easy to use, and fast to find! It's an app! You can carry it around with you and read anytime.
      internal static let text4 = L10n.tr("Localizable", "AboutTheApp.History.text4")
      /// It's mostly based on my experiences as a developer, with real-life examples that (I hope) will help you understand more about Accessibility and also help you use in your own projects!
      internal static let text5 = L10n.tr("Localizable", "AboutTheApp.History.text5")
    }
  }

  internal enum AccElem {
    /// It's important to set elements that should not be focused, such as separators or other elements without accessibility labels, to not be focused.
    internal static let comment = L10n.tr("Localizable", "AccElem.comment")
    /// This way we prevent empty content, that could confuse the user, to be focused
    internal static let comment2 = L10n.tr("Localizable", "AccElem.comment2")
    /// When using the Voice-Over, the cursor will focus on 'accessible' elements. These elements are identified by having the property accessibility element as 'True'.
    internal static let text1 = L10n.tr("Localizable", "AccElem.text1")
    /// Every element marked with this property 'True' can be focused by the Voice-Over, and the elments with the property 'False' will be ignored.
    internal static let text2 = L10n.tr("Localizable", "AccElem.text2")
    /// Turn the Voice-Over on and navigate through the next elements. Some will not be focused by it.
    internal static let text3 = L10n.tr("Localizable", "AccElem.text3")
    /// Accessibility Element
    internal static let title = L10n.tr("Localizable", "AccElem.title")
    internal enum Example {
      /// This is an accessibility element.
      internal static let isAccessibilityElement = L10n.tr("Localizable", "AccElem.example.isAccessibilityElement")
    }
  }

  internal enum AccElements {
    /// Accessibility Properties
    internal static let title = L10n.tr("Localizable", "AccElements.title")
  }

  internal enum AccHint {
    /// Hints should be optional to read. They are left as the last element so they can be skiped if the user already knows what to do.
    internal static let comment = L10n.tr("Localizable", "AccHint.comment")
    /// Accessibility hints are additional content read at the end. They are always the last content to be read.
    internal static let text1 = L10n.tr("Localizable", "AccHint.text1")
    /// They are used to provide additional information about a focused item so the user can help better understand how it works.
    internal static let text2 = L10n.tr("Localizable", "AccHint.text2")
    /// For instance: You have a cell with a long press gesture (triple tap with a single finger), you may add a hint to tell the user about this additional action.
    internal static let text3 = L10n.tr("Localizable", "AccHint.text3")
    /// Accessibility Hint
    internal static let title = L10n.tr("Localizable", "AccHint.title")
    internal enum Example {
      /// #123456
      internal static let footer = L10n.tr("Localizable", "AccHint.example.footer")
      /// Tap three times to copy the order code.
      internal static let hint = L10n.tr("Localizable", "AccHint.example.hint")
      /// French fries with cheese
      internal static let message = L10n.tr("Localizable", "AccHint.example.message")
      /// Order code copied to clipboard
      internal static let notification = L10n.tr("Localizable", "AccHint.example.notification")
      /// Your order
      internal static let title = L10n.tr("Localizable", "AccHint.example.title")
    }
  }

  internal enum AccLabel {
    /// 10 Kilograms
    internal static let accessibilityLabelExample = L10n.tr("Localizable", "AccLabel.accessibilityLabelExample")
    /// Some components automatically set their accesibility label when created, such as Texts or Buttons, but you can manually set it if necessary.
    internal static let comment = L10n.tr("Localizable", "AccLabel.comment")
    /// 10Kg
    internal static let example = L10n.tr("Localizable", "AccLabel.example")
    /// Starry Night, by Vincent Van Gogh. This is an accessibility label!
    internal static let image = L10n.tr("Localizable", "AccLabel.image")
    /// Accessibility labels are the content that is going to be read by the Voice-over when the item is focused.
    internal static let text1 = L10n.tr("Localizable", "AccLabel.text1")
    /// Every element that is focused by the Voice-Over should have an accessibility label.
    internal static let text2 = L10n.tr("Localizable", "AccLabel.text2")
    /// Turn on the Voice-Over and focus on the following element. The content read is it's accessibility label.
    internal static let text3 = L10n.tr("Localizable", "AccLabel.text3")
    /// And, sometimes, you can set a different accessibility label to a view, so its easier to understand its content, like describing measurement units or abreviations.
    internal static let text4 = L10n.tr("Localizable", "AccLabel.text4")
    /// Accessibility Label
    internal static let title = L10n.tr("Localizable", "AccLabel.title")
  }

  internal enum AccNotifications {
    /// Accessibility Notifications
    internal static let title = L10n.tr("Localizable", "AccNotifications.title")
  }

  internal enum AccPriority {
    /// Yes, you can change the reading order of your elements, but most of the time you dont want to do that.
    internal static let comment1 = L10n.tr("Localizable", "AccPriority.comment1")
    /// As a general guideline, we keep the reading order the same as the natural reading order of the current language
    internal static let comment2 = L10n.tr("Localizable", "AccPriority.comment2")
    /// For instance, English reads from left-to-right then from top-to-bottom, and thats the order the Voice-Over will try to read the content.
    internal static let comment3 = L10n.tr("Localizable", "AccPriority.comment3")
    /// See how this button even being above the elements, was the last one being focused?.
    internal static let notification = L10n.tr("Localizable", "AccPriority.notification")
    /// Accessibility Sort Priority, in SwiftUI, is a way to change the order of the elements read by the Voice-Over
    internal static let text1 = L10n.tr("Localizable", "AccPriority.text1")
    /// It is similar to defining the order of reading the elements using UIKit, but in UIKit we define this order using an array.
    internal static let text2 = L10n.tr("Localizable", "AccPriority.text2")
    /// It can be useful in some situations, check the example below:
    internal static let text3 = L10n.tr("Localizable", "AccPriority.text3")
    /// Accessibility Priority
    internal static let title = L10n.tr("Localizable", "AccPriority.title")
    internal enum Code {
      /// The highest priority is read first
      internal static let swiftUIComment = L10n.tr("Localizable", "AccPriority.Code.swiftUIComment")
      /// The content is read in the array's order
      internal static let uikitComment = L10n.tr("Localizable", "AccPriority.Code.uikitComment")
    }
  }

  internal enum AccTrait {
    /// Make sure to check that section to learn more about each trait.
    internal static let comment1 = L10n.tr("Localizable", "AccTrait.comment1")
    /// Accessibility Traits are modifiers we can add to a view in order to give some additional information or add some behavior to it.
    internal static let text1 = L10n.tr("Localizable", "AccTrait.text1")
    /// There are several traits, some of them you may never have to use, and some other ones are really powerful and you'll be gklad to know more about them.
    internal static let text2 = L10n.tr("Localizable", "AccTrait.text2")
    /// Traits are so important we have a dedicated section to them!
    internal static let text3 = L10n.tr("Localizable", "AccTrait.text3")
    /// And adding a trait to a view is very simple.
    internal static let text4 = L10n.tr("Localizable", "AccTrait.text4")
    /// Accessibility Trait
    internal static let title = L10n.tr("Localizable", "AccTrait.title")
  }

  internal enum AccTraits {
    /// Accessibility Traits
    internal static let title = L10n.tr("Localizable", "AccTraits.title")
  }

  internal enum AccValue {
    /// Check the counter example below, change its quantity and notice the 'Accessibility Value' being read.
    internal static let comment1 = L10n.tr("Localizable", "AccValue.comment1")
    /// This example was built using the 'Adjustable Trait'.
    internal static let comment2 = L10n.tr("Localizable", "AccValue.comment2")
    /// Accessibility Values represent the value (most of the times numeric) associated with your view.
    internal static let text1 = L10n.tr("Localizable", "AccValue.text1")
    /// It's mostly used in components that represents quantities, like counters, sliders or quick-adds.
    internal static let text2 = L10n.tr("Localizable", "AccValue.text2")
    /// And when changed, if the view is focused, the new value will be announced to the user.
    internal static let text3 = L10n.tr("Localizable", "AccValue.text3")
    /// Accessibility Value
    internal static let title = L10n.tr("Localizable", "AccValue.title")
  }

  internal enum Activate {
    /// Handle Action
    internal static let codeComment = L10n.tr("Localizable", "Activate.codeComment")
    /// Tap a button, click on a cell...
    internal static let comment1 = L10n.tr("Localizable", "Activate.comment1")
    /// Activating an element (double tapping it with the Voice-Over enabled) is the same as a single tap when not using the voice over.
    internal static let text1 = L10n.tr("Localizable", "Activate.text1")
    /// Most of the time, this action will hapen automatically when your cell has a tap gesture our is a button.
    internal static let text2 = L10n.tr("Localizable", "Activate.text2")
    /// But you can customize or add a specific action for the activation gesture
    internal static let text3 = L10n.tr("Localizable", "Activate.text3")
    /// Activate element
    internal static let title = L10n.tr("Localizable", "Activate.title")
  }

  internal enum Adjustable {
    /// See more on accessibility traits!
    internal static let seeMore = L10n.tr("Localizable", "Adjustable.seeMore")
    /// Adjustable components are actually using an accessibility trait.
    internal static let text1 = L10n.tr("Localizable", "Adjustable.text1")
    /// It's used on components that have some kind of quantity change or selection, like sliders, counters or quick-adds.
    internal static let text2 = L10n.tr("Localizable", "Adjustable.text2")
    /// It's very powerful, and, when focused, an adjustable view will gain the swipe up and down gestures
    internal static let text3 = L10n.tr("Localizable", "Adjustable.text3")
    /// That can be implemented to handle it's respective actions, without the need to directly tap into the buttons.
    internal static let text4 = L10n.tr("Localizable", "Adjustable.text4")
    /// Adjustable trait
    internal static let title = L10n.tr("Localizable", "Adjustable.title")
    internal enum Code {
      /// Handle decrement
      internal static let decrement = L10n.tr("Localizable", "Adjustable.Code.decrement")
      /// Handle increment
      internal static let increment = L10n.tr("Localizable", "Adjustable.Code.increment")
    }
  }

  internal enum Announcement {
    /// To me, that's where the announcements shine!
    internal static let comment1 = L10n.tr("Localizable", "Announcement.comment1")
    /// The code cells bellow are another example of announcements when you copy the code!
    internal static let comment2 = L10n.tr("Localizable", "Announcement.comment2")
    /// An announcement notification is a way to make the Voice-Over read something that is not currently focused.
    internal static let text1 = L10n.tr("Localizable", "Announcement.text1")
    /// Sometimes, some information changes on the screen and we show to the user using some animation to grab their attention.
    internal static let text2 = L10n.tr("Localizable", "Announcement.text2")
    /// But, we cannot rely on visual cues to show information when talking about visual accessibility.
    internal static let text3 = L10n.tr("Localizable", "Announcement.text3")
    /// Text to be read
    internal static let textToBeRead = L10n.tr("Localizable", "Announcement.textToBeRead")
    /// Announcement
    internal static let title = L10n.tr("Localizable", "Announcement.title")
    internal enum Notifications {
      /// This is the final message
      internal static let `final` = L10n.tr("Localizable", "Announcement.Notifications.final")
      /// Getting close to the end
      internal static let huge = L10n.tr("Localizable", "Announcement.Notifications.huge")
      /// Yep, keep increasing...
      internal static let large = L10n.tr("Localizable", "Announcement.Notifications.large")
      /// You like to increase, don't you?
      internal static let medium = L10n.tr("Localizable", "Announcement.Notifications.medium")
      /// Going negative, aren't we?
      internal static let negative = L10n.tr("Localizable", "Announcement.Notifications.negative")
      /// Oh the values are increasing!
      internal static let small = L10n.tr("Localizable", "Announcement.Notifications.small")
    }
  }

  internal enum ButtonTrait {
    /// Additional information
    internal static let additionalInformation = L10n.tr("Localizable", "ButtonTrait.additionalInformation")
    /// cell description
    internal static let cellDescription = L10n.tr("Localizable", "ButtonTrait.cellDescription")
    /// This cell was tapped
    internal static let cellTapped = L10n.tr("Localizable", "ButtonTrait.cellTapped")
    /// My Cell
    internal static let myCell = L10n.tr("Localizable", "ButtonTrait.myCell")
    /// The button trait is, to me, THE most important trait.
    internal static let text1 = L10n.tr("Localizable", "ButtonTrait.text1")
    /// It basically tells the user that they can activate the element (with a double tap) and that something will happen
    internal static let text2 = L10n.tr("Localizable", "ButtonTrait.text2")
    /// If you are using a Button or a UIButton it will automatically have the 'button' trait
    internal static let text3 = L10n.tr("Localizable", "ButtonTrait.text3")
    /// But sometimes we need to add it manually to our view, like when making a cell that can be tapped, or some other content with a tap gesture.
    internal static let text4 = L10n.tr("Localizable", "ButtonTrait.text4")
    /// Button Trait
    internal static let title = L10n.tr("Localizable", "ButtonTrait.title")
  }

  internal enum ChangeCursor {
    /// Change cursor position
    internal static let title = L10n.tr("Localizable", "ChangeCursor.title")
    internal enum Intro {
      /// But, to do that, it works different in UIKit and SwiftUI, so we are going to have a section for each in this page
      internal static let comment = L10n.tr("Localizable", "ChangeCursor.Intro.comment")
      /// Most of the time, we want the user to be in control to where the Voice-Over cursor should move to.
      internal static let text1 = L10n.tr("Localizable", "ChangeCursor.Intro.text1")
      /// Sometimes, when we change something on the screen, like presenting a modal on top of everything, we want to redirect the user directly to the new content.
      internal static let text2 = L10n.tr("Localizable", "ChangeCursor.Intro.text2")
    }
    internal enum Swiftui {
      /// You can even observe this property to handle something when it focus/unfocus on it.
      internal static let comment = L10n.tr("Localizable", "ChangeCursor.swiftui.comment")
      /// On SwiftUI, we are not going to use the Accessibility Notifications, instead, we are using the @AccessibilityFocusState
      internal static let text1 = L10n.tr("Localizable", "ChangeCursor.swiftui.text1")
      /// It allow to control if the cursor is focused on a view, and move the navigation to it.
      internal static let text2 = L10n.tr("Localizable", "ChangeCursor.swiftui.text2")
      /// First, create a new Boolean property using this wrapper
      internal static let text3 = L10n.tr("Localizable", "ChangeCursor.swiftui.text3")
      /// Then, assign it to the view you want to control by using a view modifier.
      internal static let text4 = L10n.tr("Localizable", "ChangeCursor.swiftui.text4")
      /// Now you can change the focus to the view by setting the property to 'True'.
      internal static let text5 = L10n.tr("Localizable", "ChangeCursor.swiftui.text5")
    }
    internal enum Uikit {
      /// More on Screen Change notifications.
      internal static let link = L10n.tr("Localizable", "ChangeCursor.uikit.link")
      /// To change the cursor position on UIKit, we are going to use the screen chnage notifications.
      internal static let text1 = L10n.tr("Localizable", "ChangeCursor.uikit.text1")
      /// When triggering one of these notifications, we can pass as the argument the view we want the Voice-Over to focus on.
      internal static let text2 = L10n.tr("Localizable", "ChangeCursor.uikit.text2")
    }
  }

  internal enum Collaboration {
    /// Check our GitHub project!
    internal static let githubPreoject = L10n.tr("Localizable", "Collaboration.githubPreoject")
    /// License
    internal static let license = L10n.tr("Localizable", "Collaboration.license")
    /// Submit a feature request!
    internal static let submitFeatureRequest = L10n.tr("Localizable", "Collaboration.submitFeatureRequest")
    /// Submit an issue report!
    internal static let submitIssue = L10n.tr("Localizable", "Collaboration.submitIssue")
    /// Submit a Pull Request with the changes!
    internal static let submitPR = L10n.tr("Localizable", "Collaboration.submitPR")
    /// Collaboration
    internal static let title = L10n.tr("Localizable", "Collaboration.title")
    internal enum Issue {
      /// Report to us on our GitHub project!
      internal static let text1 = L10n.tr("Localizable", "Collaboration.Issue.text1")
      /// It could be some translation problem, some accessibility issue (nobody's perfect, okay?), or anything at all!
      internal static let text2 = L10n.tr("Localizable", "Collaboration.Issue.text2")
      /// Found an issue?
      internal static let title = L10n.tr("Localizable", "Collaboration.Issue.title")
    }
    internal enum OpenSource {
      /// It's not perfect, and it's a little weird in some places... I know that, ok?
      internal static let comment1 = L10n.tr("Localizable", "Collaboration.OpenSource.comment1")
      /// Yep, the Handbook is an Open Source project!
      internal static let text1 = L10n.tr("Localizable", "Collaboration.OpenSource.text1")
      /// The idea is that the app's code can be used as examples. Take a look into the code,
      internal static let text2 = L10n.tr("Localizable", "Collaboration.OpenSource.text2")
      /// But fell free to suggest changes, fix some bugs and identify issues on our GitHub project!
      internal static let text3 = L10n.tr("Localizable", "Collaboration.OpenSource.text3")
      /// OpenSource
      internal static let title = L10n.tr("Localizable", "Collaboration.OpenSource.title")
    }
    internal enum Suggestion {
      /// Maybe you have something that you wanted to know that is not present on the app
      internal static let text1 = L10n.tr("Localizable", "Collaboration.Suggestion.text1")
      /// Or you'd like to suggest a new puzzle to add to the games.
      internal static let text2 = L10n.tr("Localizable", "Collaboration.Suggestion.text2")
      /// Fell free to tell us ay idea you have!
      internal static let text3 = L10n.tr("Localizable", "Collaboration.Suggestion.text3")
      /// Want to see something specific?
      internal static let title = L10n.tr("Localizable", "Collaboration.Suggestion.title")
    }
    internal enum Translate {
      /// It's a lot of stuff... I know, but the more the merrier!
      internal static let comment = L10n.tr("Localizable", "Collaboration.Translate.comment")
      /// If you are a developer and would like to bring the handbook closer to your community and your peers, consider helping us translating the app to other languages!
      internal static let text1 = L10n.tr("Localizable", "Collaboration.Translate.text1")
      /// You can get the project on GitHub and open a Pull Requets translating the content!
      internal static let text2 = L10n.tr("Localizable", "Collaboration.Translate.text2")
      /// Help us translate
      internal static let title = L10n.tr("Localizable", "Collaboration.Translate.title")
    }
  }

  internal enum ColorBlind {
    /// Color Blindness
    internal static let title = L10n.tr("Localizable", "ColorBlind.title")
    internal enum About {
      /// These above are examples of an Ishihara test. For a 'normal' vision person, it's expected to see '12', '6' and '74' respectively.
      internal static let comment = L10n.tr("Localizable", "ColorBlind.About.comment")
      /// Example of ishihara color identifying test.
      internal static let ishihara = L10n.tr("Localizable", "ColorBlind.About.ishihara")
      /// Ishihara Test
      internal static let ishiharaTest = L10n.tr("Localizable", "ColorBlind.About.ishiharaTest")
      /// Color blindness is a decreased ability to see color differences.
      internal static let text1 = L10n.tr("Localizable", "ColorBlind.About.text1")
      /// What you may not know is that there are 'levels' of color blindness. A person with green color deficiency, for example, may not see the green color at all, or may see it a little bit less that a non-color-blind person.
      internal static let text2 = L10n.tr("Localizable", "ColorBlind.About.text2")
      /// You may take an Ishihara test to check if you are color blind. I have a friend who discovered she was color blind when we were in college! And before that, I'd expect you to identify this condition much earlier in life.
      internal static let text3 = L10n.tr("Localizable", "ColorBlind.About.text3")
      /// But how does this affect our work when we are building an app?
      internal static let text4 = L10n.tr("Localizable", "ColorBlind.About.text4")
    }
    internal enum Handle {
      /// Using + and - may have cultural connotations, so it may not be the best example here. But it's just an example.
      internal static let comment1 = L10n.tr("Localizable", "ColorBlind.Handle.comment1")
      /// If you do rely on colors only on some part of your app, don't want to change it, but still want to to make it usable for colorblind users, check our 'Differentiate without colors' page.
      internal static let comment2 = L10n.tr("Localizable", "ColorBlind.Handle.comment2")
      /// First, make sure your content does not rely on colors only to take any actions or to identify informations. Take the example below.
      internal static let text1 = L10n.tr("Localizable", "ColorBlind.Handle.text1")
      /// Here, on the first column, we are color coding red the negative items and green the positive ones. But that's exactly what we want to avoid. The second Colum has a much better 'universal' experience where identifying these items as positive or negative does not rely solely on color.
      internal static let text2 = L10n.tr("Localizable", "ColorBlind.Handle.text2")
      /// Handling content considering colorblindness
      internal static let title = L10n.tr("Localizable", "ColorBlind.Handle.title")
    }
    internal enum Images {
      /// First, make sure to add an accessibility label to this image!
      internal static let comment = L10n.tr("Localizable", "ColorBlind.Images.comment")
      /// Sometimes we render content with images. Banners loaded from Backend, some promotional stuff, or just something that looks nicer on the image render.
      internal static let text1 = L10n.tr("Localizable", "ColorBlind.Images.text1")
      /// You also need to be careful to not have content ot be read on conflicting colors for color blindness.
      internal static let text2 = L10n.tr("Localizable", "ColorBlind.Images.text2")
      /// Careful with images
      internal static let title = L10n.tr("Localizable", "ColorBlind.Images.title")
    }
  }

  internal enum ColorsGuide {
    /// Introduction
    internal static let introduction = L10n.tr("Localizable", "ColorsGuide.introduction")
    /// Colors Guide
    internal static let title = L10n.tr("Localizable", "ColorsGuide.title")
  }

  internal enum Contrast {
    /// But why talk about contrast on an accessibility context?
    internal static let comment1 = L10n.tr("Localizable", "Contrast.comment1")
    /// But is also depends on the font itself, the font's weight...
    internal static let comment2 = L10n.tr("Localizable", "Contrast.comment2")
    /// Contrast is the difference in luminance or colour that makes an object (or its representation in an image or display) distinguishable.
    internal static let text1 = L10n.tr("Localizable", "Contrast.text1")
    /// Contrast is important when taking colors on your applications. Everything that should be visible should be well... Visible.
    internal static let text2 = L10n.tr("Localizable", "Contrast.text2")
    /// By that I mean you should be areful when adding colored text on top of colored backgrounds. The base good contrast is black-on-white (or white-on-black) text.
    internal static let text3 = L10n.tr("Localizable", "Contrast.text3")
    /// Contrast
    internal static let title = L10n.tr("Localizable", "Contrast.title")
    internal enum Example {
      /// WCAG stands for 'Web Content Accessibility Guidelines', and I know it's more directed to web, not mobile environments, but that's also nice to take a look into, specially if you are interested in learning more about contarst in accessibility.
      internal static let comment1 = L10n.tr("Localizable", "Contrast.Example.comment1")
      /// This example above fails the WCAG test for contrast.
      internal static let example1 = L10n.tr("Localizable", "Contrast.Example.example1")
      /// This one does kida ok, so you can use this color combination with larger fonts.
      internal static let example2 = L10n.tr("Localizable", "Contrast.Example.example2")
      /// And this one is pretty good! The classics.
      internal static let example3 = L10n.tr("Localizable", "Contrast.Example.example3")
      /// You can try for yourself on this contrast-check tool!
      internal static let link = L10n.tr("Localizable", "Contrast.Example.link")
      /// A nice way to test for contrast is using the WCAG contrast guide
      internal static let text1 = L10n.tr("Localizable", "Contrast.Example.text1")
    }
  }

  internal enum CustomActions {
    /// Credit Card, ending in 1234
    internal static let accessible = L10n.tr("Localizable", "CustomActions.accessible")
    /// But, when would I even use that?
    internal static let comment1 = L10n.tr("Localizable", "CustomActions.comment1")
    /// I find custom actions to be also very useful when some of the actions are hidden behind an animation, like when you need to tap an icon, something changes, and other icons appears.
    internal static let comment2 = L10n.tr("Localizable", "CustomActions.comment2")
    /// Credit Card
    internal static let creditCard = L10n.tr("Localizable", "CustomActions.creditCard")
    /// 'Custom Actions' is the name of the ability to add multiple actions to be executed on the same view. When focused, the Voice-Over will read 'actions available' at the end, meaning you can swipe up and down to change the action that will be executed when you activate the element.
    internal static let text1 = L10n.tr("Localizable", "CustomActions.text1")
    /// It's a goos tool to improve the accessibility on elements that can perform multiple actions.
    internal static let text2 = L10n.tr("Localizable", "CustomActions.text2")
    /// Like a Card cell, which can select the card, delete, edit
    internal static let text3 = L10n.tr("Localizable", "CustomActions.text3")
    /// Usually you'd have multiple buttons for each action, but focusing on each individual button would not be a very good Voice-Over experience.
    internal static let text4 = L10n.tr("Localizable", "CustomActions.text4")
    /// Custom Actions
    internal static let title = L10n.tr("Localizable", "CustomActions.title")
  }

  internal enum Differentiate {
    /// Differentiate without colors
    internal static let title = L10n.tr("Localizable", "Differentiate.title")
    internal enum Handle {
      /// To check if the feature is enabled, you can check 'UIAccessibility.shouldDifferentiateWithoutColor'
      internal static let text1 = L10n.tr("Localizable", "Differentiate.Handle.text1")
      /// And you can alo subscribe to listen to changes in this prtoperty using the Notification Center.
      internal static let text2 = L10n.tr("Localizable", "Differentiate.Handle.text2")
      /// And you can use an Environment property in SwiftUI for the same purpose.
      internal static let text3 = L10n.tr("Localizable", "Differentiate.Handle.text3")
    }
    internal enum Intro {
      /// Although, most of the time, it is a good practice to not use only colors to differentiate content. This is the kind of issue that can be prevented on the 'design step', while planning your app or your feature, and before implementing it.
      internal static let comment1 = L10n.tr("Localizable", "Differentiate.Intro.comment1")
      /// A nice example is the game 'Among Us'. On the image above, from left-to-right then top-to-bottom: no filter, deuteranopia filter, protanopia filter, tritanopia filter. These weird names are the names of some color blindness types.
      internal static let comment2 = L10n.tr("Localizable", "Differentiate.Intro.comment2")
      /// Image of the Among Us game wire game with multiple color blindness filters applyed.
      internal static let image = L10n.tr("Localizable", "Differentiate.Intro.image")
      /// The Differentiate Without Colors, is the way the user can ask to, well, do not use only colors to differentiate content.
      internal static let text1 = L10n.tr("Localizable", "Differentiate.Intro.text1")
      /// On code, it's basically going to be a boolean you can check if the user enabled this feature or not.
      internal static let text2 = L10n.tr("Localizable", "Differentiate.Intro.text2")
      /// This feature can be enabled on the device's settings at the Accessibility section.
      internal static let text3 = L10n.tr("Localizable", "Differentiate.Intro.text3")
      /// Here's a classic example, the wire game! Where you need to connect the wires with the same color on both sides of the screen.
      internal static let text4 = L10n.tr("Localizable", "Differentiate.Intro.text4")
      /// By adding icons next to the wires, you make sure the game does not rely only on color coding to be played.
      internal static let text5 = L10n.tr("Localizable", "Differentiate.Intro.text5")
    }
  }

  internal enum ElementReadingOrder {
    /// Element reading order
    internal static let title = L10n.tr("Localizable", "ElementReadingOrder.title")
  }

  internal enum Grouping {
    /// Bad Carousel
    internal static let badCarousel = L10n.tr("Localizable", "Grouping.badCarousel")
    /// Cell comment
    internal static let cellComment = L10n.tr("Localizable", "Grouping.cellComment")
    /// Cell content
    internal static let cellContent = L10n.tr("Localizable", "Grouping.cellContent")
    /// Cell title
    internal static let cellTitle = L10n.tr("Localizable", "Grouping.cellTitle")
    /// This may seem obvious, but can be easily forgotten on development.
    internal static let comment = L10n.tr("Localizable", "Grouping.comment")
    /// Good Carousel
    internal static let goodCarousel = L10n.tr("Localizable", "Grouping.goodCarousel")
    /// To me, Grouping elements correctly is one of the most important parts of building a good accessible view.
    internal static let text1 = L10n.tr("Localizable", "Grouping.text1")
    /// Imagine a carousel with a bunch of cells, when using the Voice-Over, we want the cursor to focus on each individual cell, not on the cells content.
    internal static let text2 = L10n.tr("Localizable", "Grouping.text2")
    /// Turn the Voice-Over on ans check both carousels below, one has the content correctly grouped, and the other don't.
    internal static let text3 = L10n.tr("Localizable", "Grouping.text3")
    /// Grouping Elements
    internal static let title = L10n.tr("Localizable", "Grouping.title")
    internal enum Swiftui {
      /// SwiftUI has a better wrapper to combine all children into a single accessible element.
      internal static let text = L10n.tr("Localizable", "Grouping.swiftui.text")
    }
    internal enum Uikit {
      /// On UIKit, you need to make the parent view an accessible element and not the children. Then, combine them to build the correct accessibility label for the parent.
      internal static let text = L10n.tr("Localizable", "Grouping.uikit.text")
    }
  }

  internal enum Haptic {
    /// But... why are we talking about haptics in an accessibility guide?
    internal static let comment1 = L10n.tr("Localizable", "Haptic.comment1")
    /// Haptics are little vibrations the device can make
    internal static let text1 = L10n.tr("Localizable", "Haptic.text1")
    /// There are several types of Haptics, and each one is used to represent something different.
    internal static let text2 = L10n.tr("Localizable", "Haptic.text2")
    /// Haptics are a type of feedback. When you select something, when something suceeds...
    internal static let text3 = L10n.tr("Localizable", "Haptic.text3")
    /// It's an additional layer of feedback. Imagine most actions have some kind of visual feedback, like when you tap a button and it changes it's color slightly so you know the button is pressed.
    internal static let text4 = L10n.tr("Localizable", "Haptic.text4")
    /// Since sometimes we cannot rely on visual cues, the Haptics can be a very interesting and powerful way to improve accessibility.
    internal static let text5 = L10n.tr("Localizable", "Haptic.text5")
  }

  internal enum HapticList {
    /// I also suggest you check the source code of this project. It has a nive Haptic wrapper to be used on UIKit or SwiftUI!
    internal static let comment = L10n.tr("Localizable", "HapticList.comment")
    /// Haptic source code
    internal static let sourceCode = L10n.tr("Localizable", "HapticList.sourceCode")
    /// Here's a list of the Haptics available:
    internal static let text1 = L10n.tr("Localizable", "HapticList.text1")
    /// List of Haptics
    internal static let title = L10n.tr("Localizable", "HapticList.title")
  }

  internal enum Haptics {
    /// Error
    internal static let error = L10n.tr("Localizable", "Haptics.error")
    /// Heavy Impact
    internal static let heavyImpact = L10n.tr("Localizable", "Haptics.heavyImpact")
    /// Light Impact
    internal static let lighImpact = L10n.tr("Localizable", "Haptics.lighImpact")
    /// Medium Impact
    internal static let mediumImpact = L10n.tr("Localizable", "Haptics.mediumImpact")
    /// Selection
    internal static let selection = L10n.tr("Localizable", "Haptics.selection")
    /// Success
    internal static let success = L10n.tr("Localizable", "Haptics.success")
    /// Warning
    internal static let warning = L10n.tr("Localizable", "Haptics.warning")
  }

  internal enum HeaderTrait {
    /// So... that's all?
    internal static let comment1 = L10n.tr("Localizable", "HeaderTrait.comment1")
    /// Check the Rotor and Header page!
    internal static let link = L10n.tr("Localizable", "HeaderTrait.link")
    /// The Header trait is used to describe headers (obviously), which indicates the beggining of a new content section.
    internal static let text1 = L10n.tr("Localizable", "HeaderTrait.text1")
    /// The fun part, is that you can navigate only on headers by using the rotor function.
    internal static let text2 = L10n.tr("Localizable", "HeaderTrait.text2")
    /// This way, you can skip every content that is not a header, and easily find the section you are looking for.
    internal static let text3 = L10n.tr("Localizable", "HeaderTrait.text3")
    /// Header Trait
    internal static let title = L10n.tr("Localizable", "HeaderTrait.title")
  }

  internal enum IncreaseContrast {
    /// Example of using the contrast tool. There are 6 images with increasing contrast. 
    internal static let example = L10n.tr("Localizable", "IncreaseContrast.example")
    /// Increase Contrast
    internal static let title = L10n.tr("Localizable", "IncreaseContrast.title")
    internal enum Intro {
      /// Another accessibility option the user can enable on the device's settings.
      internal static let text1 = L10n.tr("Localizable", "IncreaseContrast.Intro.text1")
      /// This one is also kinda obvious, the user is requesting to enhance contrast between foreground and background colors, so it gets easier to distinguish between them.
      internal static let text2 = L10n.tr("Localizable", "IncreaseContrast.Intro.text2")
    }
    internal enum Property {
      /// This app was built using system colors! Change the contrast options on your device's settings and check the differences!
      internal static let comment1 = L10n.tr("Localizable", "IncreaseContrast.Property.comment1")
      /// An easy way to support this is by using 'System Colors'. They will automatically adapt to the increase contrast.
      internal static let text1 = L10n.tr("Localizable", "IncreaseContrast.Property.text1")
      /// Or you can use the 'UIAccessibility.accessibilityDisplayShouldIncreaseContrast' boolen to check the current contrast state, and act accordingly.
      internal static let text2 = L10n.tr("Localizable", "IncreaseContrast.Property.text2")
      /// Handling contrast changes
      internal static let title = L10n.tr("Localizable", "IncreaseContrast.Property.title")
    }
    internal enum SwiftUI {
      /// Not that I have really used this contrast tool in any real project.
      internal static let comment1 = L10n.tr("Localizable", "IncreaseContrast.swiftUI.comment1")
      /// And in SwiftUI, there is a neat contrast tool you can use to change the contrast on your views
      internal static let text1 = L10n.tr("Localizable", "IncreaseContrast.swiftUI.text1")
    }
  }

  internal enum InvertColors {
    /// Invert Colors
    internal static let title = L10n.tr("Localizable", "InvertColors.title")
    internal enum Example {
      /// Only the second image is set to not invert colors.
      internal static let comment = L10n.tr("Localizable", "InvertColors.Example.comment")
      /// Starry night, by Van Gogh
      internal static let image1 = L10n.tr("Localizable", "InvertColors.Example.image1")
      /// Starry night, by Van Gogh. Image does not invert.
      internal static let image2 = L10n.tr("Localizable", "InvertColors.Example.image2")
      /// Change the display appearance from light/dark mode and the color inversion setting and check the images below.
      internal static let text1 = L10n.tr("Localizable", "InvertColors.Example.text1")
    }
    internal enum Intro {
      /// But why would anyone use this?
      internal static let comment1 = L10n.tr("Localizable", "InvertColors.Intro.comment1")
      /// Color Inversion is another accessibility option a user can enable on the device's settings.
      internal static let text1 = L10n.tr("Localizable", "InvertColors.Intro.text1")
      /// There are 2 types of color inversion:
      internal static let text2 = L10n.tr("Localizable", "InvertColors.Intro.text2")
      /// Classic - where everything will be inverted;
      internal static let text3 = L10n.tr("Localizable", "InvertColors.Intro.text3")
      /// Smart - where (almost) everything in light mode will be inverted, and you (the developer) can choose not to.
      internal static let text4 = L10n.tr("Localizable", "InvertColors.Intro.text4")
      /// I believe it comes down to difficulties in reading dark text on top of a white background. I myself, when I'm not using glasses, I find it pretty difficult to read content like this, so I preffer the dark mode, with white text on top of a dark background.
      internal static let text5 = L10n.tr("Localizable", "InvertColors.Intro.text5")
      /// The color inversion comes as an alternative to help you in this scenario.
      internal static let text6 = L10n.tr("Localizable", "InvertColors.Intro.text6")
    }
    internal enum WhatToDo {
      /// You basically need to mark what you don't want to be inverted. Like, images, a photo of your dog, a nice hamburguer that would look gross when inverted...
      internal static let text1 = L10n.tr("Localizable", "InvertColors.WhatToDo.text1")
      /// And to do so, you simply need to set a boolean telling you dont want this view to be inverted.
      internal static let text2 = L10n.tr("Localizable", "InvertColors.WhatToDo.text2")
      /// What to do as a developer?
      internal static let title = L10n.tr("Localizable", "InvertColors.WhatToDo.title")
    }
  }

  internal enum ListOfTraits {
    /// Allows gestures to update quantities. This is quite useful in some situations like quick-adds, sliders or counters!
    internal static let adjustable = L10n.tr("Localizable", "ListOfTraits.adjustable")
    /// 
    internal static let allowsDirectInteraction = L10n.tr("Localizable", "ListOfTraits.allowsDirectInteraction")
    /// Tells that the item is a button - can be activated with a double tap.
    internal static let button = L10n.tr("Localizable", "ListOfTraits.button")
    /// Makes an automatic page turn when it finished reading the element.
    internal static let causesPageTurn = L10n.tr("Localizable", "ListOfTraits.causesPageTurn")
    /// Since I think they are the most important ones and I actually have something to talk about. (Or I just didn't have the time yet to write something nice about this trait)
    internal static let comment1 = L10n.tr("Localizable", "ListOfTraits.comment1")
    /// But make sure to check all of their documentations!
    internal static let comment2 = L10n.tr("Localizable", "ListOfTraits.comment2")
    /// A header that can be focused with rotor function. Indicates the begining of a new section.
    internal static let header = L10n.tr("Localizable", "ListOfTraits.header")
    /// An image. It may not seem, but its important to use when actually focusing on an image. The user may want to share the image with someone, or print screen it to ask more later...
    internal static let image = L10n.tr("Localizable", "ListOfTraits.image")
    /// 
    internal static let keyboardKey = L10n.tr("Localizable", "ListOfTraits.keyboardKey")
    /// A link to a web page
    internal static let link = L10n.tr("Localizable", "ListOfTraits.link")
    /// 
    internal static let notEnabled = L10n.tr("Localizable", "ListOfTraits.notEnabled")
    /// Plays sound when activated
    internal static let playsSound = L10n.tr("Localizable", "ListOfTraits.playsSound")
    /// 
    internal static let searchField = L10n.tr("Localizable", "ListOfTraits.searchField")
    /// A selected item - used when there are more items on a list that can be selected as well (segmented controllers, radio buttons…)
    internal static let selected = L10n.tr("Localizable", "ListOfTraits.selected")
    /// Starts playing from a media session.
    internal static let startsMediaSession = L10n.tr("Localizable", "ListOfTraits.startsMediaSession")
    /// A text that does not change
    internal static let staticText = L10n.tr("Localizable", "ListOfTraits.staticText")
    /// "The accessibility element provides summary information when the app starts."
    internal static let summaryElement = L10n.tr("Localizable", "ListOfTraits.summaryElement")
    /// A tabbar item, actually very important if you have a custom tabbar!
    internal static let tabbar = L10n.tr("Localizable", "ListOfTraits.tabbar")
    /// Here's a full list of accessibility traits. Some of them are further discussed on this app
    internal static let text1 = L10n.tr("Localizable", "ListOfTraits.text1")
    /// Others are more obvious about how they should work, and where they should be used.
    internal static let text2 = L10n.tr("Localizable", "ListOfTraits.text2")
    /// List of Accessibility Traits
    internal static let title = L10n.tr("Localizable", "ListOfTraits.title")
    /// The value or label frequently changes.
    internal static let updatesFrequently = L10n.tr("Localizable", "ListOfTraits.updatesFrequently")
  }

  internal enum LongPress {
    /// Long press?
    internal static let comment1 = L10n.tr("Localizable", "LongPress.comment1")
    /// If you are using a long press gesture, I suggest always adding an accessibility hint to tell your user about it!
    internal static let comment2 = L10n.tr("Localizable", "LongPress.comment2")
    /// Long press is not an accessibility specific gesture, but I like to add it here because it has a specific gesture to be handled when using the Voice-Over.
    internal static let text1 = L10n.tr("Localizable", "LongPress.text1")
    /// To simulate a Long Press you do a triple tap when focused on the item.
    internal static let text2 = L10n.tr("Localizable", "LongPress.text2")
    /// Turn the Voice-Over on and focus on the next element. It has a long press gesture.
    internal static let text3 = L10n.tr("Localizable", "LongPress.text3")
    /// The long press is specially useful on 'Back buttons', which on newer iOS will display the navigation hierarchy, allowing you to easily navigate back to the page you want.
    internal static let text4 = L10n.tr("Localizable", "LongPress.text4")
    /// Long Press
    internal static let title = L10n.tr("Localizable", "LongPress.title")
    internal enum Code {
      /// Handle gesture
      internal static let comment = L10n.tr("Localizable", "LongPress.Code.comment")
    }
    internal enum Example {
      /// Tap three times to copy the text
      internal static let hint = L10n.tr("Localizable", "LongPress.Example.hint")
      /// Text copied to the clipboard
      internal static let notification = L10n.tr("Localizable", "LongPress.Example.notification")
      /// Some generic view in here
      internal static let text = L10n.tr("Localizable", "LongPress.Example.text")
    }
  }

  internal enum MagicTap {
    /// When implementing the 'Magic Tap', make sure it's enabled on the focused view, otherwise, it competes with the devices media player, because it's the same gesture to play/pause on the device.
    internal static let comment1 = L10n.tr("Localizable", "MagicTap.comment1")
    /// 'Magic Tap' is a double tap with two fingers gesture.
    internal static let text1 = L10n.tr("Localizable", "MagicTap.text1")
    /// You can configure the 'Magic Tap' to do basically anything.
    internal static let text2 = L10n.tr("Localizable", "MagicTap.text2")
    /// Apple's documentation suggests you use it to be a shortcut to 'your main action', such as a music player, it would be suited to play and pause actions, or on a camera app, it would be suited to take a photo.
    internal static let text3 = L10n.tr("Localizable", "MagicTap.text3")
    /// Test the Magic tap on the view below!
    internal static let text4 = L10n.tr("Localizable", "MagicTap.text4")
    /// Magic Tap
    internal static let title = L10n.tr("Localizable", "MagicTap.title")
    internal enum Example {
      /// Magic tap perfomed
      internal static let magicPerformed = L10n.tr("Localizable", "MagicTap.Example.magicPerformed")
      /// This content has a Magic Tap!
      internal static let thisContentIsMagic = L10n.tr("Localizable", "MagicTap.Example.thisContentIsMagic")
    }
  }

  internal enum Modal {
    /// Modal views
    internal static let title = L10n.tr("Localizable", "Modal.title")
    internal enum Intro {
      /// But handling Modals has some differences in UIKit and SwiftUI, so I'm splitting into a section for each one here.
      internal static let comment1 = L10n.tr("Localizable", "Modal.Intro.comment1")
      /// Read more on reading order.
      internal static let link = L10n.tr("Localizable", "Modal.Intro.link")
      /// Modal Views, in this case, we are talking about any view that is displayed on top of existing content. Banners, toasts, floating buttons...
      internal static let text1 = L10n.tr("Localizable", "Modal.Intro.text1")
      /// The problem is: The Voice-Over will try to use the language's Natural reading directions to read the content, and even if your view is on top of every other view, the Voice-Over will still focus on the content behind it.
      internal static let text2 = L10n.tr("Localizable", "Modal.Intro.text2")
      /// To prevent this issue, we can mark a view as being a 'Modal'. This will make the Voice-Over focus only on that view while it's being presented.
      internal static let text3 = L10n.tr("Localizable", "Modal.Intro.text3")
    }
    internal enum Example {
      /// This is a Bad modal
      internal static let badModal = L10n.tr("Localizable", "Modal.example.badModal")
      /// Noticed that when opening the good modal, the cursor focused directly on it? It is important when displaying a modal on top of existing content that we do that.
      internal static let comment = L10n.tr("Localizable", "Modal.example.comment")
      /// Good modal
      internal static let goodModal = L10n.tr("Localizable", "Modal.example.goodModal")
      /// Learn more about it on the Notifications section.
      internal static let link = L10n.tr("Localizable", "Modal.example.link")
      /// Turn the Voice-Over on and test the modals below.
      internal static let text1 = L10n.tr("Localizable", "Modal.example.text1")
      /// Bad modal
      internal static let thisBadModal = L10n.tr("Localizable", "Modal.example.thisBadModal")
      /// This is a Good modal
      internal static let thisGoodModal = L10n.tr("Localizable", "Modal.example.thisGoodModal")
    }
    internal enum Swiftui {
      /// On SwiftUI the 'Modal' can be set as it was an accessibility trait.
      internal static let text1 = L10n.tr("Localizable", "Modal.swiftui.text1")
    }
    internal enum Uikit {
      /// On UIKit, every UIView has the property 'accessibilityViewIsModal'. And we need to set it to 'True' if we want to mark a view as being a modal.
      internal static let text1 = L10n.tr("Localizable", "Modal.uikit.text1")
      /// But, on my experience, I find that simply setting it to 'True' sometimes does not have the expected behavior.
      internal static let text2 = L10n.tr("Localizable", "Modal.uikit.text2")
      /// I suggest overriding this property on the Modal View's class, and set it to the correct value.
      internal static let text3 = L10n.tr("Localizable", "Modal.uikit.text3")
    }
  }

  internal enum Navigation {
    /// This entire app was built to be used with the Voice-Over enabled, the concept described on the pages will always be followed by an example so you can try them by yourself!
    internal static let comment = L10n.tr("Localizable", "Navigation.comment")
    /// On top is an example of the cursor. The title 'Handbook' is currently focused on the image.
    internal static let image = L10n.tr("Localizable", "Navigation.image")
    /// Example image of the Voice-Over running on an iOS device.
    internal static let imageSubtitle = L10n.tr("Localizable", "Navigation.imageSubtitle")
    /// The Voice-Over navigation is based in gestures. Each gesture, can be perfomed anywhere on the screen, and will trigger a certain action.
    internal static let text1 = L10n.tr("Localizable", "Navigation.text1")
    /// Once enabled, the Voice-Over will display a frame on top of the current view that is being read. This frame is called 'Cursor'.
    internal static let text2 = L10n.tr("Localizable", "Navigation.text2")
    /// To navigate basically means changing the cursor's position, so it will read another element.
    internal static let text3 = L10n.tr("Localizable", "Navigation.text3")
    /// The basic navigation can be done swiping horizontally on the screen to move to cursor to the next or previous element.
    internal static let text4 = L10n.tr("Localizable", "Navigation.text4")
    /// Navigation
    internal static let title = L10n.tr("Localizable", "Navigation.title")
  }

  internal enum NotifyChanges {
    /// But what is the argument that is 'nil' on the code?
    internal static let comment1 = L10n.tr("Localizable", "NotifyChanges.comment1")
    /// Find out more about it on the following page!
    internal static let comment2 = L10n.tr("Localizable", "NotifyChanges.comment2")
    /// Layout change notification
    internal static let layoutChange = L10n.tr("Localizable", "NotifyChanges.layoutChange")
    /// Screen change notification
    internal static let screenChange = L10n.tr("Localizable", "NotifyChanges.screenChange")
    /// When something changes on the screen, we need to remember a Voice-Over user will not be able to see it.
    internal static let text1 = L10n.tr("Localizable", "NotifyChanges.text1")
    /// This is also valid to when the screen itself changes.
    internal static let text2 = L10n.tr("Localizable", "NotifyChanges.text2")
    /// But, we have some Accessibility Notifications that behave like audio cues to tell the user something has happened.
    internal static let text3 = L10n.tr("Localizable", "NotifyChanges.text3")
    /// Notify Screen changes
    internal static let title = L10n.tr("Localizable", "NotifyChanges.title")
  }

  internal enum ReduceTransparency {
    /// Reduce Transparency
    internal static let title = L10n.tr("Localizable", "ReduceTransparency.title")
    internal enum Code {
      /// And, it's pretty easy to handle!
      internal static let text1 = L10n.tr("Localizable", "ReduceTransparency.Code.text1")
      /// On UIKit, you need to check a boolean on UIAccessibility to check if the feature is enabled.
      internal static let text2 = L10n.tr("Localizable", "ReduceTransparency.Code.text2")
      /// And you can alo subscribe to listen to changes in this prtoperty using the Notification Center.
      internal static let text3 = L10n.tr("Localizable", "ReduceTransparency.Code.text3")
      /// And on SwiftUI you can use an Environment variable!
      internal static let text4 = L10n.tr("Localizable", "ReduceTransparency.Code.text4")
    }
    internal enum Example {
      /// Transparent content to be read\non top of a blured background
      internal static let example = L10n.tr("Localizable", "ReduceTransparency.Example.example")
      /// Try enabling and disabling this option and check the content below.
      internal static let text1 = L10n.tr("Localizable", "ReduceTransparency.Example.text1")
    }
    internal enum Intro {
      /// Some poeple may have a hard time looking into translucent elements!
      internal static let comment = L10n.tr("Localizable", "ReduceTransparency.Intro.comment")
      /// This is an accessibility option that needs to be enabled on the Device's settings.
      internal static let text1 = L10n.tr("Localizable", "ReduceTransparency.Intro.text1")
      /// When enabled, the user want's to tell you they want to reduce the amount of blur and translucency on the app.
      internal static let text2 = L10n.tr("Localizable", "ReduceTransparency.Intro.text2")
    }
  }
}
// swiftlint:enable explicit_type_interface function_parameter_count identifier_name line_length
// swiftlint:enable nesting type_body_length type_name vertical_whitespace_opening_braces

// MARK: - Implementation Details

extension L10n {
  private static func tr(_ table: String, _ key: String, _ args: CVarArg...) -> String {
    let format = BundleToken.bundle.localizedString(forKey: key, value: nil, table: table)
    return String(format: format, locale: Locale.current, arguments: args)
  }
}

// swiftlint:disable convenience_type
private final class BundleToken {
  static let bundle: Bundle = {
    #if SWIFT_PACKAGE
    return Bundle.module
    #else
    return Bundle(for: BundleToken.self)
    #endif
  }()
}
// swiftlint:enable convenience_type
