// swiftlint:disable all
// Generated using SwiftGen — https://github.com/SwiftGen/SwiftGen

import Foundation

// swiftlint:disable superfluous_disable_command file_length implicit_return

// MARK: - Strings

// swiftlint:disable explicit_type_interface function_parameter_count identifier_name line_length
// swiftlint:disable nesting type_body_length type_name vertical_whitespace_opening_braces
internal enum L10n {
  /// Additional cost
  internal static let additionalCost = L10n.tr("Localizable", "additionalCost")
  ///  See more on Apple's documentation for "%@"
  internal static func appleDoc(_ p1: Any) -> String {
    return L10n.tr("Localizable", "appleDoc", String(describing: p1))
  }
  /// Back to Index
  internal static let backToIndex = L10n.tr("Localizable", "backToIndex")
  /// Bell
  internal static let bell = L10n.tr("Localizable", "bell")
  /// Bold text
  internal static let boldText = L10n.tr("Localizable", "boldText")
  /// Book
  internal static let book = L10n.tr("Localizable", "book")
  /// Button
  internal static let button = L10n.tr("Localizable", "button")
  /// Close code view
  internal static let closeCodeView = L10n.tr("Localizable", "closeCodeView")
  /// Cloud
  internal static let cloud = L10n.tr("Localizable", "cloud")
  /// Code copied!
  internal static let codeCopied = L10n.tr("Localizable", "codeCopied")
  /// %@ code example.
  internal static func codeExample(_ p1: Any) -> String {
    return L10n.tr("Localizable", "codeExample", String(describing: p1))
  }
  /// Tap twice to open code in full screen, and tap three times to copy.
  internal static let codeHint = L10n.tr("Localizable", "codeHint")
  /// Color Accessibility Features
  internal static let colorAccessibilityFeatures = L10n.tr("Localizable", "ColorAccessibilityFeatures")
  /// Completed Puzzles
  internal static let completedPuzzles = L10n.tr("Localizable", "completedPuzzles")
  /// Content Hierarchy
  internal static let contentHiererachy = L10n.tr("Localizable", "ContentHiererachy")
  /// Copy Code
  internal static let copyCode = L10n.tr("Localizable", "copyCode")
  /// Dark Mode
  internal static let darkMode = L10n.tr("Localizable", "darkMode")
  /// Dedicated page
  internal static let dedicatedPage = L10n.tr("Localizable", "dedicatedPage")
  /// Delete
  internal static let delete = L10n.tr("Localizable", "delete")
  /// Deleted
  internal static let deleted = L10n.tr("Localizable", "deleted")
  /// Dismiss
  internal static let dismiss = L10n.tr("Localizable", "dismiss")
  /// Tap twice to copy
  internal static let doubleTapToCopy = L10n.tr("Localizable", "doubleTapToCopy")
  /// Early access
  internal static let earlyAccess = L10n.tr("Localizable", "earlyAccess")
  /// Edit
  internal static let edit = L10n.tr("Localizable", "edit")
  /// Edited
  internal static let edited = L10n.tr("Localizable", "edited")
  /// Example
  internal static let example = L10n.tr("Localizable", "example")
  /// Examples
  internal static let examples = L10n.tr("Localizable", "examples")
  /// Extra bureaucracy
  internal static let extraBureaucracy = L10n.tr("Localizable", "extraBureaucracy")
  /// Flag
  internal static let flag = L10n.tr("Localizable", "flag")
  /// Fog
  internal static let fog = L10n.tr("Localizable", "fog")
  /// Font size: %@
  internal static func fontSize(_ p1: Any) -> String {
    return L10n.tr("Localizable", "fontSize", String(describing: p1))
  }
  /// Free shipping
  internal static let freeShipping = L10n.tr("Localizable", "freeShipping")
  /// Go Back
  internal static let goBack = L10n.tr("Localizable", "goBack")
  /// Go play it!
  internal static let goPlay = L10n.tr("Localizable", "goPlay")
  /// Handbook
  internal static let handbook = L10n.tr("Localizable", "handbook")
  /// Handle Action
  internal static let handleAction = L10n.tr("Localizable", "handleAction")
  /// Haptic
  internal static let haptic = L10n.tr("Localizable", "haptic")
  /// Haptics
  internal static let haptics = L10n.tr("Localizable", "haptics")
  /// Hint
  internal static let hint = L10n.tr("Localizable", "Hint")
  /// Ice cream
  internal static let iceCream = L10n.tr("Localizable", "iceCream")
  /// Interaction
  internal static let interactrion = L10n.tr("Localizable", "interactrion")
  /// Light Mode
  internal static let lighMode = L10n.tr("Localizable", "lighMode")
  /// Lobster
  internal static let lobster = L10n.tr("Localizable", "lobster")
  /// Maximum
  internal static let maximum = L10n.tr("Localizable", "maximum")
  /// Minimum
  internal static let minimum = L10n.tr("Localizable", "minimum")
  /// Modal
  internal static let modal = L10n.tr("Localizable", "modal")
  /// Moon
  internal static let moon = L10n.tr("Localizable", "moon")
  /// More
  internal static let more = L10n.tr("Localizable", "more")
  /// More on the Web
  internal static let moreOnTheWeb = L10n.tr("Localizable", "moreOnTheWeb")
  /// More on Wikipedia
  internal static let moreOnWikipedia = L10n.tr("Localizable", "moreOnWikipedia")
  /// Motion
  internal static let motion = L10n.tr("Localizable", "motion")
  /// Next page %@
  internal static func nextPage(_ p1: Any) -> String {
    return L10n.tr("Localizable", "nextPage", String(describing: p1))
  }
  /// Open Settings
  internal static let openSettings = L10n.tr("Localizable", "openSettings")
  /// Paper
  internal static let paper = L10n.tr("Localizable", "paper")
  /// Paper plane
  internal static let paperPlane = L10n.tr("Localizable", "paperPlane")
  /// Password
  internal static let password = L10n.tr("Localizable", "password")
  /// Pencil
  internal static let pencil = L10n.tr("Localizable", "pencil")
  /// Potato
  internal static let potato = L10n.tr("Localizable", "potato")
  /// Pumpkin
  internal static let pumpkin = L10n.tr("Localizable", "pumpkin")
  /// Puzzles
  internal static let puzzles = L10n.tr("Localizable", "puzzles")
  /// Rain
  internal static let rain = L10n.tr("Localizable", "rain")
  /// Regular text
  internal static let regularText = L10n.tr("Localizable", "regularText")
  /// Rotor
  internal static let rotor = L10n.tr("Localizable", "Rotor")
  /// Search
  internal static let search = L10n.tr("Localizable", "Search")
  /// Select
  internal static let select = L10n.tr("Localizable", "select")
  /// Selected
  internal static let selected = L10n.tr("Localizable", "selected")
  /// Share page
  internal static let sharePage = L10n.tr("Localizable", "sharePage")
  /// Snow
  internal static let snow = L10n.tr("Localizable", "snow")
  /// Sun
  internal static let sun = L10n.tr("Localizable", "sun")
  /// Sunrise
  internal static let sunrise = L10n.tr("Localizable", "sunrise")
  /// SwiftUI
  internal static let swiftUI = L10n.tr("Localizable", "swiftUI")
  /// Tap to change
  internal static let tapToChange = L10n.tr("Localizable", "tapToChange")
  /// Tap to win
  internal static let tapToWin = L10n.tr("Localizable", "tapToWin")
  /// Accessibility Handbook
  internal static let title = L10n.tr("Localizable", "title")
  /// UIKit
  internal static let uikit = L10n.tr("Localizable", "uikit")
  /// Unfinished Puzzles
  internal static let unfinishedPuzzles = L10n.tr("Localizable", "unfinishedPuzzles")
  /// Using VoiceOver
  internal static let usingTheVoiceOver = L10n.tr("Localizable", "UsingTheVoiceOver")
  /// Visual Aid
  internal static let visualAid = L10n.tr("Localizable", "VisualAid")
  /// VoiceOver
  internal static let voiceOver = L10n.tr("Localizable", "VoiceOver")
  /// VoiceOver Guide
  internal static let voiceOverGuide = L10n.tr("Localizable", "VoiceOverGuide")
  /// Weather Icons
  internal static let weatherIcons = L10n.tr("Localizable", "weatherIcons")
  /// You are currently on: %@
  internal static func youAreCurrentlyOn(_ p1: Any) -> String {
    return L10n.tr("Localizable", "youAreCurrentlyOn", String(describing: p1))
  }

  internal enum AColorfulMessage {
    /// It is a 6 digit password
    internal static let comment = L10n.tr("Localizable", "AColorfulMessage.comment")
    /// Type in the correct password!
    internal static let text = L10n.tr("Localizable", "AColorfulMessage.text")
    /// A 'Colorful' Message
    internal static let title = L10n.tr("Localizable", "AColorfulMessage.title")
  }

  internal enum AboutColors {
    /// Some people don't experience them at all!
    internal static let comment1 = L10n.tr("Localizable", "AboutColors.comment1")
    /// I'm over extending myself into physics and biology, but bear with me.
    internal static let comment2 = L10n.tr("Localizable", "AboutColors.comment2")
    /// If you don't have a designer there... Well, I hope this content also helps you understand a little bit more about it!
    internal static let comment3 = L10n.tr("Localizable", "AboutColors.comment3")
    /// Human Interface Guidelines - Colors
    internal static let higColors = L10n.tr("Localizable", "AboutColors.higColors")
    /// Image of pretty colors
    internal static let image = L10n.tr("Localizable", "AboutColors.image")
    /// I like colors.\nBut not everybody experience them in the same way.
    internal static let text1 = L10n.tr("Localizable", "AboutColors.text1")
    /// Colors are how our brains make sense of the light that reach our eyes. We have cells that will interact with different frequencies of light, and their combination will produce what we see.
    internal static let text2 = L10n.tr("Localizable", "AboutColors.text2")
    /// And when building an app, colors are usually something that come before actually programming anything, or during what I like to call 'The design step'.
    internal static let text3 = L10n.tr("Localizable", "AboutColors.text3")
    /// So, if you are working on a team with a Designer, I highly recommend you bring these discussion to them. Understanding more about colors, how they affect the users and what we can consider accessibility while handling colors on our app.
    internal static let text4 = L10n.tr("Localizable", "AboutColors.text4")
    /// About Colors
    internal static let title = L10n.tr("Localizable", "AboutColors.title")
  }

  internal enum AboutFonts {
    /// Check some different fonts!
    internal static let link = L10n.tr("Localizable", "AboutFonts.link")
    /// About Fonts
    internal static let title = L10n.tr("Localizable", "AboutFonts.title")
    internal enum Intro {
      /// Fonts are cool.
      internal static let comment1 = L10n.tr("Localizable", "AboutFonts.Intro.comment1")
      /// This is the iOS's system font, and it is called SF Pro.
      internal static let comment2 = L10n.tr("Localizable", "AboutFonts.Intro.comment2")
      /// But since we already stablished that not everyone percieves content or colors the same way...
      internal static let comment3 = L10n.tr("Localizable", "AboutFonts.Intro.comment3")
      /// And that's where accessibility comes and it gets interesting.
      internal static let comment4 = L10n.tr("Localizable", "AboutFonts.Intro.comment4")
      /// A font is a particular size, weight and style of lettering. I like to think about the 'drawing' of the characters that make the text.
      internal static let text1 = L10n.tr("Localizable", "AboutFonts.Intro.text1")
      /// You are currently reading a text, written in a specific font.
      internal static let text2 = L10n.tr("Localizable", "AboutFonts.Intro.text2")
      /// There are several fonts. Hundreds and hundreds of thousands. And we may decide to use a custom font for our app, maybe it fits better in our content, maybe it's part of our global identity with other platforms, maybe we want to evoke a specifc feeling from the font...
      internal static let text3 = L10n.tr("Localizable", "AboutFonts.Intro.text3")
      /// But the font is how we direclty display content to the user. Most of the time we expect the user to READ the content. So, the Font used to render it is extremely important.
      internal static let text4 = L10n.tr("Localizable", "AboutFonts.Intro.text4")
      /// The basic is: We want the font to be readable.
      internal static let text5 = L10n.tr("Localizable", "AboutFonts.Intro.text5")
      /// The second part is: We want everyone, who can read, to be able to read our content.
      internal static let text6 = L10n.tr("Localizable", "AboutFonts.Intro.text6")
    }
  }

  internal enum AboutTheApp {
    /// The Handbook is available in English US and Portuguese BR. Change your language preference for the app at the device's settings.
    internal static let language = L10n.tr("Localizable", "AboutTheApp.language")
    /// About the app
    internal static let title = L10n.tr("Localizable", "AboutTheApp.title")
    internal enum Disclaimer {
      /// And I have sure learned a lot while developing this very own app!
      internal static let comment1 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.comment1")
      /// Check the Collaboration page to see more ways to report issues and to help the app's development!
      internal static let openCollaborationPage = L10n.tr("Localizable", "AboutTheApp.Disclaimer.openCollaborationPage")
      /// This app and it's content is supposed to be a helpful guide, based on real development experiences.
      internal static let text1 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text1")
      /// I do not know EVERYTHING about accessibility, and I'm learning a little bit more every day.
      internal static let text2 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text2")
      /// It may have some mistakes or misconceptions, so please, consider reporting if you find any of those.
      internal static let text3 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text3")
      /// I want it to be a reliable tool that can be cosulted during everyday development.
      internal static let text4 = L10n.tr("Localizable", "AboutTheApp.Disclaimer.text4")
      /// Disclaimer
      internal static let title = L10n.tr("Localizable", "AboutTheApp.Disclaimer.title")
    }
    internal enum Game {
      /// The puzzles are not supposed to be hard, they are just a nice way to practice your accessibility knowledge!
      internal static let comment = L10n.tr("Localizable", "AboutTheApp.Game.comment")
      /// The Handbook was pretty nice and all... but it was a little boring.
      internal static let text1 = L10n.tr("Localizable", "AboutTheApp.Game.text1")
      /// So I tryied to make something that would be nicer to use and to learn,
      internal static let text2 = L10n.tr("Localizable", "AboutTheApp.Game.text2")
      /// And what best way to do that than with a game?
      internal static let text3 = L10n.tr("Localizable", "AboutTheApp.Game.text3")
      /// What about the Game?
      internal static let title = L10n.tr("Localizable", "AboutTheApp.Game.title")
    }
    internal enum History {
      /// The Accessibility Handbook started as an idea with some colleagues and friends, aiming to be an easy way to learn more about iOS accessibility features.
      internal static let text1 = L10n.tr("Localizable", "AboutTheApp.History.text1")
      /// At the time we started working on it, but we never got to finish or publish the Handbook. So, a while later, I took what I learned and decided to bring it into the world! Rewriting the contents, adding UIKit and SwiftUI versions to make something really fresh and nice.
      internal static let text2 = L10n.tr("Localizable", "AboutTheApp.History.text2")
      /// I always thought the information about accessibility was always there, but you had to know what to look for.
      internal static let text3 = L10n.tr("Localizable", "AboutTheApp.History.text3")
      /// That's where this handbook comes, it's something that can be collaborative, easy to use, and fast to find! It's an app! You can carry it around with you and read anytime.
      internal static let text4 = L10n.tr("Localizable", "AboutTheApp.History.text4")
      /// It's mostly based on my experiences as a developer, with real-life examples that (I hope) will help you understand more about Accessibility and also help you use in your own projects!
      internal static let text5 = L10n.tr("Localizable", "AboutTheApp.History.text5")
    }
    internal enum Review {
      /// Make a review
      internal static let button = L10n.tr("Localizable", "AboutTheApp.Review.button")
      /// Review the Handbook on the AppStore!
      internal static let text = L10n.tr("Localizable", "AboutTheApp.Review.text")
    }
  }

  internal enum AccElem {
    /// It's important to set elements that should not be focused, such as separators or other elements without accessibility labels, to not be focused.
    internal static let comment = L10n.tr("Localizable", "AccElem.comment")
    /// This way we prevent empty content, that could confuse the user, to be focused
    internal static let comment2 = L10n.tr("Localizable", "AccElem.comment2")
    /// When using VoiceOver, the cursor will focus on 'accessible' elements. These elements are identified by having the property accessibility element as 'True'.
    internal static let text1 = L10n.tr("Localizable", "AccElem.text1")
    /// Every element marked with this property 'True' can be focused by VoiceOver, and the elments with the property 'False' will be ignored.
    internal static let text2 = L10n.tr("Localizable", "AccElem.text2")
    /// Turn VoiceOver on and navigate through the next elements. Some will not be focused by it.
    internal static let text3 = L10n.tr("Localizable", "AccElem.text3")
    /// Accessibility Element
    internal static let title = L10n.tr("Localizable", "AccElem.title")
    internal enum Example {
      /// This is an accessibility element.
      internal static let isAccessibilityElement = L10n.tr("Localizable", "AccElem.example.isAccessibilityElement")
    }
  }

  internal enum AccElements {
    /// Accessibility Properties
    internal static let title = L10n.tr("Localizable", "AccElements.title")
  }

  internal enum AccHint {
    /// Hints should be optional to read. They are left as the last element so they can be skiped if the user already knows what to do.
    internal static let comment = L10n.tr("Localizable", "AccHint.comment")
    /// Accessibility hints are additional content read at the end. They are always the last content to be read.
    internal static let text1 = L10n.tr("Localizable", "AccHint.text1")
    /// They are used to provide additional information about a focused item so the user can help better understand how it works.
    internal static let text2 = L10n.tr("Localizable", "AccHint.text2")
    /// For instance: You have a cell with a long press gesture (triple tap with a single finger), you may add a hint to tell the user about this additional action.
    internal static let text3 = L10n.tr("Localizable", "AccHint.text3")
    /// Accessibility Hint
    internal static let title = L10n.tr("Localizable", "AccHint.title")
    internal enum Example {
      /// #123456
      internal static let footer = L10n.tr("Localizable", "AccHint.example.footer")
      /// Tap three times to copy the order code.
      internal static let hint = L10n.tr("Localizable", "AccHint.example.hint")
      /// French fries with cheese
      internal static let message = L10n.tr("Localizable", "AccHint.example.message")
      /// Order code copied to clipboard
      internal static let notification = L10n.tr("Localizable", "AccHint.example.notification")
      /// Your order
      internal static let title = L10n.tr("Localizable", "AccHint.example.title")
    }
  }

  internal enum AccLabel {
    /// 10 Kilograms
    internal static let accessibilityLabelExample = L10n.tr("Localizable", "AccLabel.accessibilityLabelExample")
    /// Some components automatically set their accesibility label when created, such as Texts or Buttons, but you can manually set it if necessary.
    internal static let comment = L10n.tr("Localizable", "AccLabel.comment")
    /// 10Kg
    internal static let example = L10n.tr("Localizable", "AccLabel.example")
    /// Starry Night, by Vincent Van Gogh. This is an accessibility label!
    internal static let image = L10n.tr("Localizable", "AccLabel.image")
    /// Accessibility labels are the content that is going to be read by VoiceOver when the item is focused.
    internal static let text1 = L10n.tr("Localizable", "AccLabel.text1")
    /// Every element that is focused by VoiceOver should have an accessibility label.
    internal static let text2 = L10n.tr("Localizable", "AccLabel.text2")
    /// Turn on VoiceOver and focus on the following element. The content read is it's accessibility label.
    internal static let text3 = L10n.tr("Localizable", "AccLabel.text3")
    /// And, sometimes, you can set a different accessibility label to a view, so its easier to understand its content, like describing measurement units or abreviations.
    internal static let text4 = L10n.tr("Localizable", "AccLabel.text4")
    /// Accessibility Label
    internal static let title = L10n.tr("Localizable", "AccLabel.title")
  }

  internal enum AccNotifications {
    /// Accessibility Notifications
    internal static let title = L10n.tr("Localizable", "AccNotifications.title")
  }

  internal enum AccPriority {
    /// Yes, you can change the reading order of your elements, but most of the time you dont want to do that.
    internal static let comment1 = L10n.tr("Localizable", "AccPriority.comment1")
    /// As a general guideline, we keep the reading order the same as the natural reading order of the current language
    internal static let comment2 = L10n.tr("Localizable", "AccPriority.comment2")
    /// For instance, English reads from left-to-right then from top-to-bottom, and thats the order VoiceOver will try to read the content.
    internal static let comment3 = L10n.tr("Localizable", "AccPriority.comment3")
    /// See how this button even being above the elements, was the last one being focused?.
    internal static let notification = L10n.tr("Localizable", "AccPriority.notification")
    /// Accessibility Sort Priority, in SwiftUI, is a way to change the order of the elements read by VoiceOver
    internal static let text1 = L10n.tr("Localizable", "AccPriority.text1")
    /// It is similar to defining the order of reading the elements using UIKit, but in UIKit we define this order using an array.
    internal static let text2 = L10n.tr("Localizable", "AccPriority.text2")
    /// It can be useful in some situations, check the example below:
    internal static let text3 = L10n.tr("Localizable", "AccPriority.text3")
    /// Accessibility Priority
    internal static let title = L10n.tr("Localizable", "AccPriority.title")
    internal enum Code {
      /// The highest priority is read first
      internal static let swiftUIComment = L10n.tr("Localizable", "AccPriority.Code.swiftUIComment")
      /// The content is read in the array's order
      internal static let uikitComment = L10n.tr("Localizable", "AccPriority.Code.uikitComment")
    }
  }

  internal enum AccTrait {
    /// Make sure to check that section to learn more about each trait.
    internal static let comment1 = L10n.tr("Localizable", "AccTrait.comment1")
    /// Accessibility Traits are modifiers we can add to a view in order to give some additional information or add some behavior to it.
    internal static let text1 = L10n.tr("Localizable", "AccTrait.text1")
    /// There are several traits, some of them you may never have to use, and some other ones are really powerful and you'll be glad to know more about them.
    internal static let text2 = L10n.tr("Localizable", "AccTrait.text2")
    /// Traits are so important we have a dedicated section to them!
    internal static let text3 = L10n.tr("Localizable", "AccTrait.text3")
    /// And adding a trait to a view is very simple.
    internal static let text4 = L10n.tr("Localizable", "AccTrait.text4")
    /// Accessibility Trait
    internal static let title = L10n.tr("Localizable", "AccTrait.title")
  }

  internal enum AccTraits {
    /// Accessibility Traits
    internal static let title = L10n.tr("Localizable", "AccTraits.title")
  }

  internal enum AccValue {
    /// Check the counter example below, change its quantity and notice the 'Accessibility Value' being read.
    internal static let comment1 = L10n.tr("Localizable", "AccValue.comment1")
    /// This example was built using the 'Adjustable Trait'.
    internal static let comment2 = L10n.tr("Localizable", "AccValue.comment2")
    /// Accessibility Values represent the value (most of the times numeric) associated with your view.
    internal static let text1 = L10n.tr("Localizable", "AccValue.text1")
    /// It's mostly used in components that represents quantities, like counters, sliders or quick-adds.
    internal static let text2 = L10n.tr("Localizable", "AccValue.text2")
    /// And when changed, if the view is focused, the new value will be announced to the user.
    internal static let text3 = L10n.tr("Localizable", "AccValue.text3")
    /// Accessibility Value
    internal static let title = L10n.tr("Localizable", "AccValue.title")
  }

  internal enum Activate {
    /// Handle Action
    internal static let codeComment = L10n.tr("Localizable", "Activate.codeComment")
    /// Tap a button, click on a cell...
    internal static let comment1 = L10n.tr("Localizable", "Activate.comment1")
    /// Activating an element (double tapping it with VoiceOver enabled) is the same as a single tap when not using the voice over.
    internal static let text1 = L10n.tr("Localizable", "Activate.text1")
    /// Most of the time, this action will hapen automatically when your cell has a tap gesture our is a button.
    internal static let text2 = L10n.tr("Localizable", "Activate.text2")
    /// But you can customize or add a specific action for the activation gesture
    internal static let text3 = L10n.tr("Localizable", "Activate.text3")
    /// Activate element
    internal static let title = L10n.tr("Localizable", "Activate.title")
  }

  internal enum AdjustLayoutToScaledFontPage {
    /// Adjust Layout to Scaled Fonts
    internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.title")
    internal enum AllowTextToIncrease {
      /// This is the complicated part, you need to make the layout accounting for text changes and visualize what would break and handle it correctly so it keeps working with bigger fonts.
      internal static let comment1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.AllowTextToIncrease.comment1")
      /// In this case, it would also be nice to set a minimum size for the content, in case of smaller fonts that could also break the expected layout.
      internal static let comment2 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.AllowTextToIncrease.comment2")
      /// Sometimes, the text does not define alone out content size, but it's paired with an image or something else that controls the dimensions.
      internal static let text1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.AllowTextToIncrease.text1")
      /// To better support dynamic fonts, you need to make your layout expand beyond the size of the paired content, but keep everything still cohesive.
      internal static let text2 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.AllowTextToIncrease.text2")
      /// Allow text to control the size of the content
      internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.AllowTextToIncrease.title")
    }
    internal enum Example {
      /// Content body some content
      internal static let body = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Example.body")
      /// Content description
      internal static let description = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Example.description")
      /// Content title
      internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Example.title")
    }
    internal enum FixedSize {
      /// The main rule is: Avoid fixed sizes as much as possible. When enlarging the font, it will probably not break the layout itself, but the content that is being displayed.
      internal static let text1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.FixedSize.text1")
      /// Fixed size
      internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.FixedSize.title")
    }
    internal enum Intro {
      /// Hiding content is never a good solution, so we need to check approaches to make everything work with any size of font.
      internal static let comment1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Intro.comment1")
      /// This is also important to be discussed with your design team!
      internal static let comment2 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Intro.comment2")
      /// The most difficult part of supporting dynamic fonts is: "Your carefully crafted layout is probably going to break once the labels increase or decrease in size."
      internal static let text1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Intro.text1")
      /// We need to consider what we want to happen once the font increases. \nWill it break into a new line?\nWill part of the content just be cut off?\nWill the view itself increase in size?
      internal static let text2 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Intro.text2")
      /// Check the following examples by changing the settings for the font size on your device and checking how each one behaves.
      internal static let text3 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.Intro.text3")
    }
    internal enum LineBreak {
      /// Make sure you are expecting this! Sometimes we do not want our cells or groups to increase too much because it can break our entire layout.
      internal static let comment1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.LineBreak.comment1")
      /// By allowing the text to line break you can support displaying the content independently of it's size. But the issue is: It will probably increase the size of your layout vertically.
      internal static let text1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.LineBreak.text1")
      /// Allow line breaking
      internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.LineBreak.title")
    }
    internal enum ScaleSize {
      /// I think it's a nice solution when paired with multiline text, but, you need to make sure to test it with different content sizes.
      internal static let comment1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.ScaleSize.comment1")
      /// Another option, is allowing your content to scale it's size up to a limit so it doesn't break the layout (that much).
      internal static let text1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.ScaleSize.text1")
      /// Scale size up to a limit
      internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.ScaleSize.title")
    }
    internal enum WhatOption {
      /// That's why implementing Dynamic fonts after an app is ready and in production is so difficult. Literally anything can break.
      internal static let comment1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.WhatOption.comment1")
      /// Well, that's the hard part. It depends. It depends on where the text is at, it depends on how we want to scale our content (can our cells get wider?\nShould we break the lines instead?)
      internal static let text1 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.WhatOption.text1")
      /// But, such as adjusting the content to support screen readers, implementing dynamic fonts is a group work. Talk with your designers, question them "What should happen if this title had an enlarged font?", and bring all these discussion points to when you are building the layout.
      internal static let text2 = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.WhatOption.text2")
      /// Which option should I use?
      internal static let title = L10n.tr("Localizable", "AdjustLayoutToScaledFontPage.WhatOption.title")
    }
  }

  internal enum Adjustable {
    /// See more on accessibility traits!
    internal static let seeMore = L10n.tr("Localizable", "Adjustable.seeMore")
    /// Adjustable components are actually using an accessibility trait.
    internal static let text1 = L10n.tr("Localizable", "Adjustable.text1")
    /// It's used on components that have some kind of quantity change or selection, like sliders, counters or quick-adds.
    internal static let text2 = L10n.tr("Localizable", "Adjustable.text2")
    /// It's very powerful, and, when focused, an adjustable view will gain the swipe up and down gestures
    internal static let text3 = L10n.tr("Localizable", "Adjustable.text3")
    /// That can be implemented to handle it's respective actions, without the need to directly tap into the buttons.
    internal static let text4 = L10n.tr("Localizable", "Adjustable.text4")
    /// Adjustable trait
    internal static let title = L10n.tr("Localizable", "Adjustable.title")
    internal enum Code {
      /// Handle decrement
      internal static let decrement = L10n.tr("Localizable", "Adjustable.Code.decrement")
      /// Handle increment
      internal static let increment = L10n.tr("Localizable", "Adjustable.Code.increment")
    }
  }

  internal enum AnAlternative {
    /// You should alternate between... something... and try to enable items in the correct order.
    internal static let text = L10n.tr("Localizable", "AnAlternative.text")
    /// An alternative
    internal static let title = L10n.tr("Localizable", "AnAlternative.title")
  }

  internal enum Announcement {
    /// To me, that's where the announcements shine!
    internal static let comment1 = L10n.tr("Localizable", "Announcement.comment1")
    /// The code cells bellow are another example of announcements when you copy the code!
    internal static let comment2 = L10n.tr("Localizable", "Announcement.comment2")
    /// An announcement notification is a way to make VoiceOver read something that is not currently focused.
    internal static let text1 = L10n.tr("Localizable", "Announcement.text1")
    /// Sometimes, some information changes on the screen and we show to the user using some animation to grab their attention.
    internal static let text2 = L10n.tr("Localizable", "Announcement.text2")
    /// But, we cannot rely on visual cues to show information when talking about visual accessibility.
    internal static let text3 = L10n.tr("Localizable", "Announcement.text3")
    /// Text to be read
    internal static let textToBeRead = L10n.tr("Localizable", "Announcement.textToBeRead")
    /// Announcement
    internal static let title = L10n.tr("Localizable", "Announcement.title")
    internal enum Notifications {
      /// This is the final message
      internal static let `final` = L10n.tr("Localizable", "Announcement.Notifications.final")
      /// Getting close to the end
      internal static let huge = L10n.tr("Localizable", "Announcement.Notifications.huge")
      /// Yep, keep increasing...
      internal static let large = L10n.tr("Localizable", "Announcement.Notifications.large")
      /// You like to increase, don't you?
      internal static let medium = L10n.tr("Localizable", "Announcement.Notifications.medium")
      /// Going negative, aren't we?
      internal static let negative = L10n.tr("Localizable", "Announcement.Notifications.negative")
      /// Oh the values are increasing!
      internal static let small = L10n.tr("Localizable", "Announcement.Notifications.small")
    }
  }

  internal enum Appearances {
    /// Supporting dark mode.
    internal static let supportingDarkMode = L10n.tr("Localizable", "Appearances.supportingDarkMode")
    /// Appearance changes
    internal static let title = L10n.tr("Localizable", "Appearances.title")
    internal enum Code {
      /// The main complication is the existence of the `unspecified` case in the 'UIUserInterfaceStyle' enum, (because of course it exists) but in this case, just throw your default variation of the content.
      internal static let comment1 = L10n.tr("Localizable", "Appearances.Code.comment1")
      /// In SwiftUI, it's as easy as an Environment variable. So it will automatically be notified whenever the user changes this setting, and your app will adjust itself automatically.
      internal static let text1 = L10n.tr("Localizable", "Appearances.Code.text1")
      /// And, of course, things are a little more complicated in UIKit, you need to use the 'UITraitCollection' object.
      internal static let text2 = L10n.tr("Localizable", "Appearances.Code.text2")
      /// And, in order to handle dynamic changes on the user interface style, you need to listen to changes on the trait collection object in a UIView or UIViewController, and update your content whenever it changes.
      internal static let text3 = L10n.tr("Localizable", "Appearances.Code.text3")
      /// Identify current color scheme
      internal static let title = L10n.tr("Localizable", "Appearances.Code.title")
    }
    internal enum Intro {
      /// In this context, appearences is the group of possible interface color schemes the users can select on their iOS devices. Currently: dark or light modes.
      internal static let text1 = L10n.tr("Localizable", "Appearances.Intro.text1")
      /// We can identify which of these the user has currently selected and adjust our content accordingly.
      internal static let text2 = L10n.tr("Localizable", "Appearances.Intro.text2")
    }
  }

  internal enum BePatient {
    /// Pacience is the key...
    internal static let comment = L10n.tr("Localizable", "BePatient.comment")
    /// Tap the elements in the correct order!
    internal static let text = L10n.tr("Localizable", "BePatient.text")
    /// Be Patient
    internal static let title = L10n.tr("Localizable", "BePatient.title")
  }

  internal enum BoldedText {
    /// Bolded Text
    internal static let title = L10n.tr("Localizable", "BoldedText.title")
    internal enum Code {
      /// This app fully supports bolded fonts, change the accessibility option on the device's setting and check how the app behaves.
      internal static let comment1 = L10n.tr("Localizable", "BoldedText.Code.comment1")
      /// It's also important to notice that fonts that are already bold, become even 'bolder' when manually adjusting these changes.
      internal static let text1 = L10n.tr("Localizable", "BoldedText.Code.text1")
    }
    internal enum Intro {
      /// When using custom fonts, you may need to manually define it's weight when necessary.
      internal static let comment1 = L10n.tr("Localizable", "BoldedText.Intro.comment1")
      /// "Bolded Text" is another accessibility option that can be enabled on the system settings.
      internal static let text1 = L10n.tr("Localizable", "BoldedText.Intro.text1")
      /// It's mainly used by people with lower vision to help reading content on your app by enlarging the font's weight.
      internal static let text2 = L10n.tr("Localizable", "BoldedText.Intro.text2")
      /// When using system fonts, they will automatically adapt themselves to the user's defined setting for the weight.
      internal static let text3 = L10n.tr("Localizable", "BoldedText.Intro.text3")
    }
  }

  internal enum ButtonShapes {
    /// Button Shapes
    internal static let title = L10n.tr("Localizable", "ButtonShapes.title")
    internal enum Code {
      /// If you need to identify to make any manual changes on your content, you can use a static variable on UIKit or an Environment variable on SwiftUI.
      internal static let text1 = L10n.tr("Localizable", "ButtonShapes.Code.text1")
    }
    internal enum Example {
      /// It's nice to notice that not all buttons will have the same highlight. The back button in the navigation bar will be underlined, for instance.
      internal static let comment1 = L10n.tr("Localizable", "ButtonShapes.Example.comment1")
      /// Check the multiple examples of buttons below, then enable the 'Button Shapes' feature on the device's setting to see how they behave.
      internal static let text1 = L10n.tr("Localizable", "ButtonShapes.Example.text1")
    }
    internal enum Intro {
      /// If you are using 'UIButton' or a 'Button', this highlight will automatically be displayed whenever the feature is enabled.
      internal static let comment1 = L10n.tr("Localizable", "ButtonShapes.Intro.comment1")
      /// "Button Shapes" is another accessibility option that can be enabled on the system settings.
      internal static let text1 = L10n.tr("Localizable", "ButtonShapes.Intro.text1")
      /// The idea is to highlight buttons, by adding outlines to them, in order to help users identify which contents are interactable while using your application.
      internal static let text2 = L10n.tr("Localizable", "ButtonShapes.Intro.text2")
    }
  }

  internal enum ButtonTrait {
    /// Additional information
    internal static let additionalInformation = L10n.tr("Localizable", "ButtonTrait.additionalInformation")
    /// cell description
    internal static let cellDescription = L10n.tr("Localizable", "ButtonTrait.cellDescription")
    /// This cell was tapped
    internal static let cellTapped = L10n.tr("Localizable", "ButtonTrait.cellTapped")
    /// My Cell
    internal static let myCell = L10n.tr("Localizable", "ButtonTrait.myCell")
    /// The button trait is, to me, THE most important trait.
    internal static let text1 = L10n.tr("Localizable", "ButtonTrait.text1")
    /// It basically tells the user that they can activate the element (with a double tap) and that something will happen
    internal static let text2 = L10n.tr("Localizable", "ButtonTrait.text2")
    /// If you are using a Button or a UIButton it will automatically have the 'button' trait
    internal static let text3 = L10n.tr("Localizable", "ButtonTrait.text3")
    /// But sometimes we need to add it manually to our view, like when making a cell that can be tapped, or some other content with a tap gesture.
    internal static let text4 = L10n.tr("Localizable", "ButtonTrait.text4")
    /// Button Trait
    internal static let title = L10n.tr("Localizable", "ButtonTrait.title")
  }

  internal enum ChangeCursor {
    /// Change cursor position
    internal static let title = L10n.tr("Localizable", "ChangeCursor.title")
    internal enum Intro {
      /// But, to do that, it works different in UIKit and SwiftUI, so we are going to have a section for each in this page
      internal static let comment = L10n.tr("Localizable", "ChangeCursor.Intro.comment")
      /// Most of the time, we want the user to be in control to where VoiceOver cursor should move to.
      internal static let text1 = L10n.tr("Localizable", "ChangeCursor.Intro.text1")
      /// Sometimes, when we change something on the screen, like presenting a modal on top of everything, we want to redirect the user directly to the new content.
      internal static let text2 = L10n.tr("Localizable", "ChangeCursor.Intro.text2")
    }
    internal enum Swiftui {
      /// You can even observe this property to handle something when it focus/unfocus on it.
      internal static let comment = L10n.tr("Localizable", "ChangeCursor.swiftui.comment")
      /// On SwiftUI, we are not going to use the Accessibility Notifications, instead, we are using the @AccessibilityFocusState
      internal static let text1 = L10n.tr("Localizable", "ChangeCursor.swiftui.text1")
      /// It allow to control if the cursor is focused on a view, and move the navigation to it.
      internal static let text2 = L10n.tr("Localizable", "ChangeCursor.swiftui.text2")
      /// First, create a new Boolean property using this wrapper
      internal static let text3 = L10n.tr("Localizable", "ChangeCursor.swiftui.text3")
      /// Then, assign it to the view you want to control by using a view modifier.
      internal static let text4 = L10n.tr("Localizable", "ChangeCursor.swiftui.text4")
      /// Now you can change the focus to the view by setting the property to 'True'.
      internal static let text5 = L10n.tr("Localizable", "ChangeCursor.swiftui.text5")
    }
    internal enum Uikit {
      /// More on Screen Change notifications.
      internal static let link = L10n.tr("Localizable", "ChangeCursor.uikit.link")
      /// To change the cursor position on UIKit, we are going to use the screen change notifications.
      internal static let text1 = L10n.tr("Localizable", "ChangeCursor.uikit.text1")
      /// When triggering one of these notifications, we can pass as the argument the view we want VoiceOver to focus on.
      internal static let text2 = L10n.tr("Localizable", "ChangeCursor.uikit.text2")
    }
  }

  internal enum Collaboration {
    /// Check our GitHub project!
    internal static let githubPreoject = L10n.tr("Localizable", "Collaboration.githubPreoject")
    /// License
    internal static let license = L10n.tr("Localizable", "Collaboration.license")
    /// Submit a feature request!
    internal static let submitFeatureRequest = L10n.tr("Localizable", "Collaboration.submitFeatureRequest")
    /// Submit an issue report!
    internal static let submitIssue = L10n.tr("Localizable", "Collaboration.submitIssue")
    /// Submit a Pull Request with the changes!
    internal static let submitPR = L10n.tr("Localizable", "Collaboration.submitPR")
    /// Collaboration
    internal static let title = L10n.tr("Localizable", "Collaboration.title")
    internal enum Issue {
      /// Report to us on our GitHub project!
      internal static let text1 = L10n.tr("Localizable", "Collaboration.Issue.text1")
      /// It could be some translation problem, some accessibility issue (nobody's perfect, okay?), or anything at all!
      internal static let text2 = L10n.tr("Localizable", "Collaboration.Issue.text2")
      /// Found an issue?
      internal static let title = L10n.tr("Localizable", "Collaboration.Issue.title")
    }
    internal enum OpenSource {
      /// It's not perfect, and it's a little weird in some places... I know that, ok?
      internal static let comment1 = L10n.tr("Localizable", "Collaboration.OpenSource.comment1")
      /// Yep, the Handbook is an Open Source project!
      internal static let text1 = L10n.tr("Localizable", "Collaboration.OpenSource.text1")
      /// The idea is that the app's code can be used as examples. Take a look into the code, see for yourself how the feature actually works when running on an app.
      internal static let text2 = L10n.tr("Localizable", "Collaboration.OpenSource.text2")
      /// But fell free to suggest changes, fix some bugs and identify issues on our GitHub project!
      internal static let text3 = L10n.tr("Localizable", "Collaboration.OpenSource.text3")
      /// OpenSource
      internal static let title = L10n.tr("Localizable", "Collaboration.OpenSource.title")
    }
    internal enum Suggestion {
      /// Maybe you have something that you wanted to know that is not present on the app
      internal static let text1 = L10n.tr("Localizable", "Collaboration.Suggestion.text1")
      /// Or you'd like to suggest a new puzzle to add to the games.
      internal static let text2 = L10n.tr("Localizable", "Collaboration.Suggestion.text2")
      /// Fell free to tell us ay idea you have!
      internal static let text3 = L10n.tr("Localizable", "Collaboration.Suggestion.text3")
      /// Want to see something specific?
      internal static let title = L10n.tr("Localizable", "Collaboration.Suggestion.title")
    }
    internal enum Translate {
      /// It's a lot of stuff... I know, but the more the merrier!
      internal static let comment = L10n.tr("Localizable", "Collaboration.Translate.comment")
      /// If you are a developer and would like to bring the handbook closer to your community and your peers, consider helping us translating the app to other languages!
      internal static let text1 = L10n.tr("Localizable", "Collaboration.Translate.text1")
      /// You can get the project on GitHub and open a Pull Requets translating the content!
      internal static let text2 = L10n.tr("Localizable", "Collaboration.Translate.text2")
      /// Help us translate
      internal static let title = L10n.tr("Localizable", "Collaboration.Translate.title")
    }
  }

  internal enum ColorBlind {
    /// Color Blindness
    internal static let title = L10n.tr("Localizable", "ColorBlind.title")
    internal enum About {
      /// These above are examples of an Ishihara test. For a 'normal' vision person, it's expected to see '12', '6' and '74' respectively.
      internal static let comment = L10n.tr("Localizable", "ColorBlind.About.comment")
      /// Example of ishihara color identifying test.
      internal static let ishihara = L10n.tr("Localizable", "ColorBlind.About.ishihara")
      /// Ishihara Test
      internal static let ishiharaTest = L10n.tr("Localizable", "ColorBlind.About.ishiharaTest")
      /// Color blindness is a decreased ability to see color differences.
      internal static let text1 = L10n.tr("Localizable", "ColorBlind.About.text1")
      /// What you may not know is that there are 'levels' of color blindness. A person with green color deficiency, for example, may not see the green color at all, or may see it a little bit less that a non-color-blind person.
      internal static let text2 = L10n.tr("Localizable", "ColorBlind.About.text2")
      /// You may take an Ishihara test to check if you are color blind. I have a friend who discovered she was color blind when we were in college! And before that, I'd expect you to identify this condition much earlier in life.
      internal static let text3 = L10n.tr("Localizable", "ColorBlind.About.text3")
      /// But how does this affect our work when we are building an app?
      internal static let text4 = L10n.tr("Localizable", "ColorBlind.About.text4")
    }
    internal enum Handle {
      /// Using + and - may have cultural connotations, so it may not be the best example here. But it's just an example.
      internal static let comment1 = L10n.tr("Localizable", "ColorBlind.Handle.comment1")
      /// If you do rely on colors only on some part of your app, don't want to change it, but still want to to make it usable for colorblind users, check our 'Differentiate without colors' page.
      internal static let comment2 = L10n.tr("Localizable", "ColorBlind.Handle.comment2")
      /// First, make sure your content does not rely on colors only to take any actions or to identify informations. Take the example below.
      internal static let text1 = L10n.tr("Localizable", "ColorBlind.Handle.text1")
      /// Here, on the first column, we are color coding red the negative items and green the positive ones. But that's exactly what we want to avoid. The second Colum has a much better 'universal' experience where identifying these items as positive or negative does not rely solely on color.
      internal static let text2 = L10n.tr("Localizable", "ColorBlind.Handle.text2")
      /// Handling content considering colorblindness
      internal static let title = L10n.tr("Localizable", "ColorBlind.Handle.title")
    }
    internal enum Images {
      /// First, make sure to add an accessibility label to this image!
      internal static let comment = L10n.tr("Localizable", "ColorBlind.Images.comment")
      /// Sometimes we render content with images. Banners loaded from Backend, some promotional stuff, or just something that looks nicer on the image render.
      internal static let text1 = L10n.tr("Localizable", "ColorBlind.Images.text1")
      /// You also need to be careful to not have content ot be read on conflicting colors for color blindness.
      internal static let text2 = L10n.tr("Localizable", "ColorBlind.Images.text2")
      /// Careful with images
      internal static let title = L10n.tr("Localizable", "ColorBlind.Images.title")
    }
  }

  internal enum ColorsGuide {
    /// Introduction
    internal static let introduction = L10n.tr("Localizable", "ColorsGuide.introduction")
    /// Colors Guide
    internal static let title = L10n.tr("Localizable", "ColorsGuide.title")
  }

  internal enum Contrast {
    /// But why talk about contrast on an accessibility context?
    internal static let comment1 = L10n.tr("Localizable", "Contrast.comment1")
    /// But is also depends on the font itself, the font's weight...
    internal static let comment2 = L10n.tr("Localizable", "Contrast.comment2")
    /// Contrast is the difference in luminance or colour that makes an object (or its representation in an image or display) distinguishable.
    internal static let text1 = L10n.tr("Localizable", "Contrast.text1")
    /// Contrast is important when taking colors on your applications. Everything that should be visible should be well... Visible.
    internal static let text2 = L10n.tr("Localizable", "Contrast.text2")
    /// By that I mean you should be careful when adding colored text on top of colored backgrounds. The base good contrast is black-on-white (or white-on-black) text.
    internal static let text3 = L10n.tr("Localizable", "Contrast.text3")
    /// Contrast
    internal static let title = L10n.tr("Localizable", "Contrast.title")
    internal enum Example {
      /// WCAG stands for 'Web Content Accessibility Guidelines', and I know it's more directed to web, not mobile environments, but that's also nice to take a look into, specially if you are interested in learning more about contrast in accessibility.
      internal static let comment1 = L10n.tr("Localizable", "Contrast.Example.comment1")
      /// This example above fails the WCAG test for contrast.
      internal static let example1 = L10n.tr("Localizable", "Contrast.Example.example1")
      /// This one does kida ok, so you can use this color combination with larger fonts.
      internal static let example2 = L10n.tr("Localizable", "Contrast.Example.example2")
      /// And this one is pretty good! The classics.
      internal static let example3 = L10n.tr("Localizable", "Contrast.Example.example3")
      /// You can try for yourself on this contrast-check tool!
      internal static let link = L10n.tr("Localizable", "Contrast.Example.link")
      /// A nice way to test for contrast is using the WCAG contrast guide
      internal static let text1 = L10n.tr("Localizable", "Contrast.Example.text1")
    }
  }

  internal enum CustomActions {
    /// Credit Card, ending in 1234
    internal static let accessible = L10n.tr("Localizable", "CustomActions.accessible")
    /// But, when would I even use that?
    internal static let comment1 = L10n.tr("Localizable", "CustomActions.comment1")
    /// I find custom actions to be also very useful when some of the actions are hidden behind an animation, like when you need to tap an icon, something changes, and other icons appears.
    internal static let comment2 = L10n.tr("Localizable", "CustomActions.comment2")
    /// Credit Card
    internal static let creditCard = L10n.tr("Localizable", "CustomActions.creditCard")
    /// 'Custom Actions' is the name of the ability to add multiple actions to be executed on the same view. When focused, VoiceOver will read 'actions available' at the end, meaning you can swipe up and down to change the action that will be executed when you activate the element.
    internal static let text1 = L10n.tr("Localizable", "CustomActions.text1")
    /// It's a good tool to improve the accessibility on elements that can perform multiple actions.
    internal static let text2 = L10n.tr("Localizable", "CustomActions.text2")
    /// Like a Card cell, which can select the card, delete, edit
    internal static let text3 = L10n.tr("Localizable", "CustomActions.text3")
    /// Usually you'd have multiple buttons for each action, but focusing on each individual button would not be a very good VoiceOver experience.
    internal static let text4 = L10n.tr("Localizable", "CustomActions.text4")
    /// Custom Actions
    internal static let title = L10n.tr("Localizable", "CustomActions.title")
  }

  internal enum Differentiate {
    /// Differentiate without colors
    internal static let title = L10n.tr("Localizable", "Differentiate.title")
    internal enum Handle {
      /// To check if the feature is enabled, you can check 'UIAccessibility.shouldDifferentiateWithoutColor'
      internal static let text1 = L10n.tr("Localizable", "Differentiate.Handle.text1")
      /// And you can alo subscribe to listen to changes in this property using the Notification Center.
      internal static let text2 = L10n.tr("Localizable", "Differentiate.Handle.text2")
      /// And you can use an Environment property in SwiftUI for the same purpose.
      internal static let text3 = L10n.tr("Localizable", "Differentiate.Handle.text3")
    }
    internal enum Intro {
      /// Although, most of the time, it is a good practice to not use only colors to differentiate content. This is the kind of issue that can be prevented on the 'design step', while planning your app or your feature, and before implementing it.
      internal static let comment1 = L10n.tr("Localizable", "Differentiate.Intro.comment1")
      /// A nice example is the game 'Among Us'. On the image above, from left-to-right then top-to-bottom: no filter, deuteranopia filter, protanopia filter, tritanopia filter. These weird names are the names of some color blindness types.
      internal static let comment2 = L10n.tr("Localizable", "Differentiate.Intro.comment2")
      /// Image of the Among Us game wire game with multiple color blindness filters applyed.
      internal static let image = L10n.tr("Localizable", "Differentiate.Intro.image")
      /// The Differentiate Without Colors, is the way the user can ask to, well, do not use only colors to differentiate content.
      internal static let text1 = L10n.tr("Localizable", "Differentiate.Intro.text1")
      /// On code, it's basically going to be a boolean you can check if the user enabled this feature or not.
      internal static let text2 = L10n.tr("Localizable", "Differentiate.Intro.text2")
      /// This feature can be enabled on the device's settings at the Accessibility section.
      internal static let text3 = L10n.tr("Localizable", "Differentiate.Intro.text3")
      /// Here's a classic example, the wire game! Where you need to connect the wires with the same color on both sides of the screen.
      internal static let text4 = L10n.tr("Localizable", "Differentiate.Intro.text4")
      /// By adding icons next to the wires, you make sure the game does not rely only on color coding to be played.
      internal static let text5 = L10n.tr("Localizable", "Differentiate.Intro.text5")
    }
  }

  internal enum DismissPage {
    /// Try it out! Enable VoiceOver and perform a 'Z' with 2 fingers.
    internal static let comment1 = L10n.tr("Localizable", "DismissPage.comment1")
    /// VoiceOver has a dedicated 'dismiss gesture', the Escape, which is used to close modals or pop the current view on the navigation stack.
    internal static let text1 = L10n.tr("Localizable", "DismissPage.text1")
    /// Escape
    internal static let title = L10n.tr("Localizable", "DismissPage.title")
    internal enum Handle {
      /// On UIKit, you can add a custom handling to this gesture by implementing the 'perform escape' method.
      internal static let text1 = L10n.tr("Localizable", "DismissPage.Handle.text1")
      /// On SwiftUI, it's the same as adding a 'Magic Tap' action, but using the escape type.
      internal static let text2 = L10n.tr("Localizable", "DismissPage.Handle.text2")
    }
  }

  internal enum DynamicColors {
    /// Dynamic colors
    internal static let title = L10n.tr("Localizable", "DynamicColors.title")
    internal enum CustomColors {
      /// Apple's documentation suggests usign Color Assets for this, which we'll cover in the following page.
      internal static let comment1 = L10n.tr("Localizable", "DynamicColors.CustomColors.comment1")
      /// When using custom colors, you will need to manually select the correct color for the current appearance.
      internal static let text1 = L10n.tr("Localizable", "DynamicColors.CustomColors.text1")
      /// But most of the time we have a separate library for our colors or a JSON file with the hex codes, and we manually create our color objects.
      internal static let text2 = L10n.tr("Localizable", "DynamicColors.CustomColors.text2")
      /// We can use a specific init in the 'UIColor' object, which gives the current UITraitCollection object, to wrap our color file and help us define the correct color for the context.
      internal static let text3 = L10n.tr("Localizable", "DynamicColors.CustomColors.text3")
      /// And in SwiftUI we can use the color scheme Environment property to help us define the correct color.
      internal static let text4 = L10n.tr("Localizable", "DynamicColors.CustomColors.text4")
      /// The issue, most of the times, is supporting changes on the color scheme with the app running. Make sure to reload the colors on your UIView or ude the color scheme Environment property on your SwiftUI Views.
      internal static let text5 = L10n.tr("Localizable", "DynamicColors.CustomColors.text5")
      /// Custom colors
      internal static let title = L10n.tr("Localizable", "DynamicColors.CustomColors.title")
    }
    internal enum Intro {
      /// When talking about supporting Dark Mode, 'dynamic colors' is the capability of colors to correctly adjust themselves to the current color scheme.
      internal static let text1 = L10n.tr("Localizable", "DynamicColors.Intro.text1")
    }
    internal enum SystemColors {
      /// SwiftUI 'Color' currently does not have these system colors, but you can map the 'UIColor' object into a 'Color' if you want.
      internal static let comment1 = L10n.tr("Localizable", "DynamicColors.SystemColors.comment1")
      /// When using System colors, they may automatically adjust themselves to the current color scheme.
      internal static let text1 = L10n.tr("Localizable", "DynamicColors.SystemColors.text1")
      /// This is true to background and label colors.
      internal static let text2 = L10n.tr("Localizable", "DynamicColors.SystemColors.text2")
      /// UIColors also have colors with the 'system' preffix, which means they are adaptable to color scheme as well.
      internal static let text3 = L10n.tr("Localizable", "DynamicColors.SystemColors.text3")
      /// System colors
      internal static let title = L10n.tr("Localizable", "DynamicColors.SystemColors.title")
    }
  }

  internal enum DynamicContent {
    /// Dynamic Assets
    internal static let title = L10n.tr("Localizable", "DynamicContent.title")
    internal enum Intro {
      /// When talking about supporting dark mode, we do not need to talk only about changing colors between the color schemes, but other contents can also be adapted to different modes.
      internal static let text1 = L10n.tr("Localizable", "DynamicContent.Intro.text1")
      /// Here we'll be addressing assets, specially images, but the same thing applies to color assets.
      internal static let text2 = L10n.tr("Localizable", "DynamicContent.Intro.text2")
    }
    internal enum XCTAssets {
      /// Above is an image of the Xcode's asset catalog. When selecting an image asset, the right panel will display the 'Appearance' option, which you can enable to add images for light and dark modes.
      internal static let image1 = L10n.tr("Localizable", "DynamicContent.XCTAssets.image1")
      /// When using XCAssets on Xcode, they provide options to support different assets for different color schemes, along side multiple assets for different screen dimensions. This can be used in both images and color assets.
      internal static let text1 = L10n.tr("Localizable", "DynamicContent.XCTAssets.text1")
      /// Specially when the images have background colors or are difficult to see on a specific color scheme, you can provide different assets for them.
      internal static let text2 = L10n.tr("Localizable", "DynamicContent.XCTAssets.text2")
      /// When switching from dark/light mode and if you are using the XCTAssets the images will automatically change themselves to the correct version.
      internal static let text3 = L10n.tr("Localizable", "DynamicContent.XCTAssets.text3")
      /// The examples below have been built using the XCTAssets and have different assets for each color scheme. Change between light and dark mode and check how they behave.
      internal static let text4 = L10n.tr("Localizable", "DynamicContent.XCTAssets.text4")
      /// XCAssets
      internal static let title = L10n.tr("Localizable", "DynamicContent.XCTAssets.title")
    }
  }

  internal enum DynamicFonts {
    /// Implementing Dynamic Fonts
    internal static let implementing = L10n.tr("Localizable", "DynamicFonts.implementing")
    /// Dynamic Fonts
    internal static let title = L10n.tr("Localizable", "DynamicFonts.title")
  }

  internal enum ElementReadingOrder {
    /// What does it mean?
    internal static let comment1 = L10n.tr("Localizable", "ElementReadingOrder.comment1")
    /// You can change the reading order of your elements... if you want...
    internal static let comment2 = L10n.tr("Localizable", "ElementReadingOrder.comment2")
    /// Check the 'Accessibility Priority' page for more informations
    internal static let link = L10n.tr("Localizable", "ElementReadingOrder.link")
    /// VoiceOver will read the content on the screen trying to follow the 'Natural reading direction of the Language'
    internal static let text1 = L10n.tr("Localizable", "ElementReadingOrder.text1")
    /// For instance, English, the natural reading directions is left-to-right then up-to-down
    internal static let text2 = L10n.tr("Localizable", "ElementReadingOrder.text2")
    /// So the Voice Over will follow this same order when reading the content.
    internal static let text3 = L10n.tr("Localizable", "ElementReadingOrder.text3")
    /// But when we are talking about a single focused element (the element the cursor is currently at)
    internal static let text4 = L10n.tr("Localizable", "ElementReadingOrder.text4")
    /// The content will be read in the following order:
    internal static let text5 = L10n.tr("Localizable", "ElementReadingOrder.text5")
    /// Element reading order
    internal static let title = L10n.tr("Localizable", "ElementReadingOrder.title")
  }

  internal enum EnableVoiceOver {
    /// Beyond providing faster access to turning VoiceOver on, it also helps to turn it off if you get stuck while using the it.
    internal static let comment = L10n.tr("Localizable", "EnableVoiceOver.comment")
    /// VoiceOver is the name of the iOS's native screen reader solution. Used to provide visual impairment accessibility.
    internal static let text1 = L10n.tr("Localizable", "EnableVoiceOver.text1")
    /// To enable VoiceOver, go to the device's settings, on the 'Accessibility section'.
    internal static let text2 = L10n.tr("Localizable", "EnableVoiceOver.text2")
    /// Then, navigate to VoiceOver and turn the toggle on.
    internal static let text3 = L10n.tr("Localizable", "EnableVoiceOver.text3")
    /// As an alternative to doing this every time you want to enable VoiceOver, you may navigate to the Accessibility section again, and change the 'Accessibility shortcut' section.
    internal static let text4 = L10n.tr("Localizable", "EnableVoiceOver.text4")
    /// There, select the features you want to have quick-access to (make sure to select VoiceOver)
    internal static let text5 = L10n.tr("Localizable", "EnableVoiceOver.text5")
    /// And now, you can access any of those features by triple-pressing the side button on your device (the one that locks the screen).
    internal static let text6 = L10n.tr("Localizable", "EnableVoiceOver.text6")
    /// Enable VoiceOver
    internal static let title = L10n.tr("Localizable", "EnableVoiceOver.title")
  }

  internal enum FillTheCup {
    /// You just need to find a way to do it
    internal static let comment = L10n.tr("Localizable", "FillTheCup.comment")
    /// Fill the circles all the way up!
    internal static let text = L10n.tr("Localizable", "FillTheCup.text")
    /// Fill the Cup
    internal static let title = L10n.tr("Localizable", "FillTheCup.title")
  }

  internal enum FindThePassword {
    /// You just need to find out what the password is...
    internal static let comment = L10n.tr("Localizable", "FindThePassword.comment")
    /// You need to type in the correct password!
    internal static let text1 = L10n.tr("Localizable", "FindThePassword.text1")
    /// It's as simple as that
    internal static let text2 = L10n.tr("Localizable", "FindThePassword.text2")
    /// Find the Password
    internal static let title = L10n.tr("Localizable", "FindThePassword.title")
  }

  internal enum Fonts {
    /// Fonts
    internal static let title = L10n.tr("Localizable", "Fonts.title")
  }

  internal enum GameCell {
    /// You have already succeeded in this puzzle!
    internal static let finishedHint = L10n.tr("Localizable", "GameCell.finishedHint")
    /// You haven't finished this puzzle yet
    internal static let unfinishedHint = L10n.tr("Localizable", "GameCell.unfinishedHint")
  }

  internal enum GameSuccess {
    /// You solved the puzzle!
    internal static let subtitle = L10n.tr("Localizable", "GameSuccess.subtitle")
    /// Suggested reading
    internal static let suggestedReading = L10n.tr("Localizable", "GameSuccess.suggestedReading")
    /// If you want to learn more about this puzzle check our documentation
    internal static let text = L10n.tr("Localizable", "GameSuccess.text")
    /// Congratulations!
    internal static let title = L10n.tr("Localizable", "GameSuccess.title")
  }

  internal enum GameView {
    /// Try solving these puzzles to learn more about accessibility features!
    internal static let comment = L10n.tr("Localizable", "GameView.comment")
  }

  internal enum Gesture {
    /// Animation representing the gesture for %@
    internal static func accessible(_ p1: Any) -> String {
      return L10n.tr("Localizable", "Gesture.accessible", String(describing: p1))
    }
    /// 'Z' with 2 fingers.
    internal static let dismiss = L10n.tr("Localizable", "Gesture.dismiss")
    /// Double Tap
    internal static let doubleTap = L10n.tr("Localizable", "Gesture.doubleTap")
    /// Four fingers double tap.
    internal static let fourFingersDoubleTap = L10n.tr("Localizable", "Gesture.fourFingersDoubleTap")
    /// Single Tap
    internal static let singleTap = L10n.tr("Localizable", "Gesture.singleTap")
    /// Swipe Down
    internal static let swipeDown = L10n.tr("Localizable", "Gesture.swipeDown")
    /// Swipe Left
    internal static let swipeLeft = L10n.tr("Localizable", "Gesture.swipeLeft")
    /// Swipe Right
    internal static let swipeRight = L10n.tr("Localizable", "Gesture.swipeRight")
    /// Swipe Up
    internal static let swipeUp = L10n.tr("Localizable", "Gesture.swipeUp")
    /// Three fingers double tap
    internal static let threeFingersDoubleTap = L10n.tr("Localizable", "Gesture.threeFingersDoubleTap")
    /// Three fingers single tap
    internal static let threeFingersSingleTap = L10n.tr("Localizable", "Gesture.threeFingersSingleTap")
    /// Three fingers swipe down
    internal static let threeFingersSwipeDown = L10n.tr("Localizable", "Gesture.threeFingersSwipeDown")
    /// Three fingers swipe left
    internal static let threeFingersSwipeLeft = L10n.tr("Localizable", "Gesture.threeFingersSwipeLeft")
    /// Three fingers swipe right
    internal static let threeFingersSwipeRight = L10n.tr("Localizable", "Gesture.threeFingersSwipeRight")
    /// Three fingers swipe up
    internal static let threeFingersSwipeUp = L10n.tr("Localizable", "Gesture.threeFingersSwipeUp")
    /// Three fingers triple tap
    internal static let threeFingersTripleTap = L10n.tr("Localizable", "Gesture.threeFingersTripleTap")
    /// Triple Tap
    internal static let tripleTap = L10n.tr("Localizable", "Gesture.tripleTap")
    /// Two fingers double Tap
    internal static let twoFingersDoubleTap = L10n.tr("Localizable", "Gesture.twoFingersDoubleTap")
    /// Two fingers single Tap
    internal static let twoFingersSingleTap = L10n.tr("Localizable", "Gesture.twoFingersSingleTap")
    /// Two fingers swipe down
    internal static let twoFingersSwipeDown = L10n.tr("Localizable", "Gesture.twoFingersSwipeDown")
    /// Two fingers swipe up
    internal static let twoFingersSwipeUp = L10n.tr("Localizable", "Gesture.twoFingersSwipeUp")
  }

  internal enum Gestures {
    /// Gesture Helper
    internal static let helper = L10n.tr("Localizable", "Gestures.helper")
    /// Reading
    internal static let reading = L10n.tr("Localizable", "Gestures.reading")
    /// Here's an initial guide to start using VoiceOver gestures.
    internal static let text1 = L10n.tr("Localizable", "Gestures.text1")
    /// Gestures Guide
    internal static let title = L10n.tr("Localizable", "Gestures.title")
    internal enum Dismiss {
      /// Gesture to dismiss modals and pop to preview view on navigation stack.
      internal static let description = L10n.tr("Localizable", "Gestures.dismiss.description")
    }
    internal enum DoubleTap {
      /// Activate element, the same as tapping it when the VoicOver is disabled.
      internal static let description = L10n.tr("Localizable", "Gestures.doubleTap.description")
    }
    internal enum FourFingersDoubleTap {
      /// Start/Stop gesture helper. When enabled, it will tell every gesture performed and what it does.
      internal static let description = L10n.tr("Localizable", "Gestures.fourFingersDoubleTap.description")
    }
    internal enum SingleTap {
      /// Read focused element
      internal static let description = L10n.tr("Localizable", "Gestures.singleTap.description")
    }
    internal enum SwipeDown {
      /// Change Rotor filter / Decrease adjustable element / Change selected custom action
      internal static let description = L10n.tr("Localizable", "Gestures.swipeDown.description")
    }
    internal enum SwipeLeft {
      /// Move cursor to the previous element
      internal static let description = L10n.tr("Localizable", "Gestures.swipeLeft.description")
    }
    internal enum SwipeRight {
      /// Move cursor to the next element
      internal static let description = L10n.tr("Localizable", "Gestures.swipeRight.description")
    }
    internal enum SwipeUp {
      /// Change Rotor filter / Increase adjustable element / Change selected custom action
      internal static let description = L10n.tr("Localizable", "Gestures.swipeUp.description")
    }
    internal enum ThreeFingersDoubleTap {
      /// Mute/unmute the screen reader
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersDoubleTap.description")
    }
    internal enum ThreeFingersSingleTap {
      /// Read item summary. It will also describe the cursor position on the screen.
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersSingleTap.description")
    }
    internal enum ThreeFingersSwipeDown {
      /// Scroll up.
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersSwipeDown.description")
    }
    internal enum ThreeFingersSwipeLeft {
      /// Scroll right.
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersSwipeLeft.description")
    }
    internal enum ThreeFingersSwipeRight {
      /// Scroll left.
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersSwipeRight.description")
    }
    internal enum ThreeFingersSwipeUp {
      /// Scroll down.
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersSwipeUp.description")
    }
    internal enum ThreeFingersTripleTap {
      /// Enable/disable the screen curtain. Turns the screen off but the content is still running.
      internal static let description = L10n.tr("Localizable", "Gestures.threeFingersTripleTap.description")
    }
    internal enum TripleTap {
      /// Long press gesture
      internal static let description = L10n.tr("Localizable", "Gestures.tripleTap.description")
    }
    internal enum TwoFingersDoubleTap {
      /// Execute Magic Tap.
      internal static let description = L10n.tr("Localizable", "Gestures.twoFingersDoubleTap.description")
    }
    internal enum TwoFingersSingleTap {
      /// Pause/Play reading. You can make VoiceOver pause the current reading, and by making the same gesture again, it will keep going from where it stoped.
      internal static let description = L10n.tr("Localizable", "Gestures.twoFingersSingleTap.description")
    }
    internal enum TwoFingersSwipeDown {
      /// Read all - will starting readin the content automatically.
      internal static let description = L10n.tr("Localizable", "Gestures.twoFingersSwipeDown.description")
    }
    internal enum TwoFingersSwipeUp {
      /// Read from top - will move the cursor to the top of the page.
      internal static let description = L10n.tr("Localizable", "Gestures.twoFingersSwipeUp.description")
    }
  }

  internal enum Grouping {
    /// Bad Carousel
    internal static let badCarousel = L10n.tr("Localizable", "Grouping.badCarousel")
    /// Cell comment
    internal static let cellComment = L10n.tr("Localizable", "Grouping.cellComment")
    /// Cell content
    internal static let cellContent = L10n.tr("Localizable", "Grouping.cellContent")
    /// Cell title
    internal static let cellTitle = L10n.tr("Localizable", "Grouping.cellTitle")
    /// This may seem obvious, but can be easily forgotten on development.
    internal static let comment = L10n.tr("Localizable", "Grouping.comment")
    /// Good Carousel
    internal static let goodCarousel = L10n.tr("Localizable", "Grouping.goodCarousel")
    /// To me, Grouping elements correctly is one of the most important parts of building a good accessible view.
    internal static let text1 = L10n.tr("Localizable", "Grouping.text1")
    /// Imagine a carousel with a bunch of cells, when using VoiceOver, we want the cursor to focus on each individual cell, not on the cells content.
    internal static let text2 = L10n.tr("Localizable", "Grouping.text2")
    /// Turn VoiceOver on and check both carousels below, one has the content correctly grouped, and the other don't.
    internal static let text3 = L10n.tr("Localizable", "Grouping.text3")
    /// Grouping Elements
    internal static let title = L10n.tr("Localizable", "Grouping.title")
    internal enum Swiftui {
      /// SwiftUI has a better wrapper to combine all children into a single accessible element.
      internal static let text = L10n.tr("Localizable", "Grouping.swiftui.text")
    }
    internal enum Uikit {
      /// On UIKit, you need to make the parent view an accessible element and not the children. Then, combine them to build the correct accessibility label for the parent.
      internal static let text = L10n.tr("Localizable", "Grouping.uikit.text")
    }
  }

  internal enum Haptic {
    /// But... why are we talking about haptics in an accessibility guide?
    internal static let comment1 = L10n.tr("Localizable", "Haptic.comment1")
    /// Haptics are little vibrations the device can make
    internal static let text1 = L10n.tr("Localizable", "Haptic.text1")
    /// There are several types of Haptics, and each one is used to represent something different.
    internal static let text2 = L10n.tr("Localizable", "Haptic.text2")
    /// Haptics are a type of feedback. When you select something, when something suceeds...
    internal static let text3 = L10n.tr("Localizable", "Haptic.text3")
    /// It's an additional layer of feedback. Imagine most actions have some kind of visual feedback, like when you tap a button and it changes it's color slightly so you know the button is pressed.
    internal static let text4 = L10n.tr("Localizable", "Haptic.text4")
    /// Since sometimes we cannot rely on visual cues, the Haptics can be a very interesting and powerful way to improve accessibility.
    internal static let text5 = L10n.tr("Localizable", "Haptic.text5")
  }

  internal enum HapticList {
    /// I also suggest you check the source code of this project. It has a nice Haptic wrapper to be used on UIKit or SwiftUI!
    internal static let comment = L10n.tr("Localizable", "HapticList.comment")
    /// Haptics are not available on iPad, the buttons below may not work on your current device.
    internal static let iPadDisclaimer = L10n.tr("Localizable", "HapticList.iPadDisclaimer")
    /// Haptic source code
    internal static let sourceCode = L10n.tr("Localizable", "HapticList.sourceCode")
    /// Here's a list of the Haptics available:
    internal static let text1 = L10n.tr("Localizable", "HapticList.text1")
    /// List of Haptics
    internal static let title = L10n.tr("Localizable", "HapticList.title")
  }

  internal enum Haptics {
    /// Error
    internal static let error = L10n.tr("Localizable", "Haptics.error")
    /// Heavy Impact
    internal static let heavyImpact = L10n.tr("Localizable", "Haptics.heavyImpact")
    /// Light Impact
    internal static let lighImpact = L10n.tr("Localizable", "Haptics.lighImpact")
    /// Medium Impact
    internal static let mediumImpact = L10n.tr("Localizable", "Haptics.mediumImpact")
    /// Selection
    internal static let selection = L10n.tr("Localizable", "Haptics.selection")
    /// Success
    internal static let success = L10n.tr("Localizable", "Haptics.success")
    /// Warning
    internal static let warning = L10n.tr("Localizable", "Haptics.warning")
  }

  internal enum HeaderTrait {
    /// So... that's all?
    internal static let comment1 = L10n.tr("Localizable", "HeaderTrait.comment1")
    /// Check the Rotor and Header page!
    internal static let link = L10n.tr("Localizable", "HeaderTrait.link")
    /// The Header trait is used to describe headers (obviously), which indicates the beggining of a new content section.
    internal static let text1 = L10n.tr("Localizable", "HeaderTrait.text1")
    /// The fun part, is that you can navigate only on headers by using the rotor function.
    internal static let text2 = L10n.tr("Localizable", "HeaderTrait.text2")
    /// This way, you can skip every content that is not a header, and easily find the section you are looking for.
    internal static let text3 = L10n.tr("Localizable", "HeaderTrait.text3")
    /// Header Trait
    internal static let title = L10n.tr("Localizable", "HeaderTrait.title")
  }

  internal enum Hint {
    /// Close hint
    internal static let close = L10n.tr("Localizable", "Hint.close")
    /// Activate to get a hint on how to solve this puzzle.
    internal static let hint = L10n.tr("Localizable", "Hint.hint")
    /// Open hint
    internal static let `open` = L10n.tr("Localizable", "Hint.open")
    /// The Handbook puzzles were made to be solved using some kind of accessibility tool (or a combination of them).
    internal static let text1 = L10n.tr("Localizable", "Hint.text1")
    /// If you can't figure it out, maybe this page will help you...
    internal static let text2 = L10n.tr("Localizable", "Hint.text2")
    /// 🤔 Having Trouble?
    internal static let title = L10n.tr("Localizable", "Hint.title")
  }

  internal enum Home {
    /// Collaborate
    internal static let collaborate = L10n.tr("Localizable", "Home.collaborate")
    /// Colors
    internal static let colors = L10n.tr("Localizable", "Home.colors")
    /// Development Guides
    internal static let developmentGuides = L10n.tr("Localizable", "Home.developmentGuides")
    /// Dynamic Fonts
    internal static let dynamicFonts = L10n.tr("Localizable", "Home.dynamicFonts")
    /// The Handbook Game
    internal static let handbookGame = L10n.tr("Localizable", "Home.handbookGame")
    /// Test your accessibility knowledge in a series of puzzles!
    internal static let handbookGameDescription = L10n.tr("Localizable", "Home.handbookGameDescription")
    /// Notify
    internal static let notifications = L10n.tr("Localizable", "Home.notifications")
    /// Other Features
    internal static let otherFeatures = L10n.tr("Localizable", "Home.otherFeatures")
    /// Shortcuts
    internal static let shortcuts = L10n.tr("Localizable", "Home.shortcuts")
  }

  internal enum IdentifyCurrentPreferredFontSizePage {
    /// Identify preferred content size
    internal static let title = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.title")
    internal enum Example {
      /// Larger Accessibility Sizes
      internal static let toggle = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Example.toggle")
    }
    internal enum Intro {
      /// When selecting the preferred font size on the device's settings, multiple sizes and options are available.
      internal static let text1 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Intro.text1")
      /// Even without enabling the accessibility option, the user can still select different font sizes.
      internal static let text2 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Intro.text2")
      /// You may want to identify the currently selected font size to take additional actions on your device, you can do that by checking the preferred content size category on UIApplication.
      internal static let text3 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Intro.text3")
    }
    internal enum List {
      /// Example list of sizes
      internal static let title = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.List.title")
    }
    internal enum Variations {
      /// The content below is a recriation of the system's settings, and it's just an example. Slide the indicator to see how the value changes.
      internal static let comment1 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Variations.comment1")
      /// When the accessibility option is disabled, the size varies from extra small to extra extra extra large.
      internal static let text1 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Variations.text1")
      /// And when the accessibility option is enabled, it goes from accessibility medium to accessibility extra extra extra large.
      internal static let text2 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Variations.text2")
      /// The thing is: The accessibility medium is larger than then regular extra extra extra large size.
      internal static let text3 = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Variations.text3")
      /// Variations
      internal static let title = L10n.tr("Localizable", "IdentifyCurrentPreferredFontSizePage.Variations.title")
    }
  }

  internal enum ImageTrait {
    /// Image description
    internal static let description = L10n.tr("Localizable", "ImageTrait.description")
    /// The image trait is good for images or other visual elements that have no text or action.
    internal static let text1 = L10n.tr("Localizable", "ImageTrait.text1")
    /// If you are using an Image or an UIImage it will automatically have the image trait. However, you may also want to apply this trait to other elements, such as graphics or animations.
    internal static let text2 = L10n.tr("Localizable", "ImageTrait.text2")
    /// This will make the Voice Over to identify and read the element as an image.
    internal static let text3 = L10n.tr("Localizable", "ImageTrait.text3")
    /// Image Trait
    internal static let title = L10n.tr("Localizable", "ImageTrait.title")
  }

  internal enum ImplementingDynamicFonts {
    /// Scaling Fonts Automatically
    internal static let title = L10n.tr("Localizable", "ImplementingDynamicFonts.title")
    internal enum Intro {
      /// Thats what we call 'Dynamic fonts'.
      internal static let comment1 = L10n.tr("Localizable", "ImplementingDynamicFonts.Intro.comment1")
      /// In the example above, we are using a fixed font size (36), which will not cut it if we are expecting our font to scale itself automatically.
      internal static let comment2 = L10n.tr("Localizable", "ImplementingDynamicFonts.Intro.comment2")
      /// Scaling fonts automatically is the property of a label or text to automatically increase the font size according to the user's accessibility settings.
      internal static let text1 = L10n.tr("Localizable", "ImplementingDynamicFonts.Intro.text1")
      /// To support this, we stop using 'fixed' font sizes, and start working with 'text styles'.
      internal static let text2 = L10n.tr("Localizable", "ImplementingDynamicFonts.Intro.text2")
    }
    internal enum SystemFonts {
      /// The tough part comes with custom fonts, that we'll be discussing more on the following pages.
      internal static let comment1 = L10n.tr("Localizable", "ImplementingDynamicFonts.SystemFonts.comment1")
      /// The easiest way to support scaling your fonts automatically, is using the system defined text styles and fonts.
      internal static let text1 = L10n.tr("Localizable", "ImplementingDynamicFonts.SystemFonts.text1")
      /// They are going to work seemelesly with the user changes on font sizes.
      internal static let text2 = L10n.tr("Localizable", "ImplementingDynamicFonts.SystemFonts.text2")
      /// System Fonts
      internal static let title = L10n.tr("Localizable", "ImplementingDynamicFonts.SystemFonts.title")
    }
    internal enum TextStyles {
      /// So don't worry, your content will still have differences between titles and bodies and comments, and every other text-style you are using.
      internal static let comment1 = L10n.tr("Localizable", "ImplementingDynamicFonts.TextStyles.comment1")
      /// Text styles represent a context for your font (title, body, caption...), instead of a fixed font size.
      internal static let text1 = L10n.tr("Localizable", "ImplementingDynamicFonts.TextStyles.text1")
      /// The font size will be defined by what is the current configuration on the device's settings, and it will scale every text style accordingly.
      internal static let text2 = L10n.tr("Localizable", "ImplementingDynamicFonts.TextStyles.text2")
      /// Also, If the 'adjustsFontForContentSizeCategory' property is set to 'False', the font will initially be the right size, but it won't respond to text-size changes the user makes in Settings or Control Center.
      internal static let text3 = L10n.tr("Localizable", "ImplementingDynamicFonts.TextStyles.text3")
      /// Text Styles
      internal static let title = L10n.tr("Localizable", "ImplementingDynamicFonts.TextStyles.title")
    }
  }

  internal enum Impostor {
    /// Ask them, maybe they'll tell you.
    internal static let comment = L10n.tr("Localizable", "Impostor.comment")
    /// Type the impostor's name
    internal static let field = L10n.tr("Localizable", "Impostor.field")
    /// I'm not the impostor
    internal static let hint = L10n.tr("Localizable", "Impostor.hint")
    /// Yes, I'm the impostor
    internal static let impostor = L10n.tr("Localizable", "Impostor.impostor")
    /// Find the impostor, and type it's name!
    internal static let text = L10n.tr("Localizable", "Impostor.text")
    /// Impostor
    internal static let title = L10n.tr("Localizable", "Impostor.title")
  }

  internal enum Impostor2 {
    /// Ask them, maybe they'll tell you.
    internal static let comment = L10n.tr("Localizable", "Impostor2.comment")
    /// Type the impostor's name
    internal static let field = L10n.tr("Localizable", "Impostor2.field")
    /// Find the impostor, and type it's name!
    internal static let text = L10n.tr("Localizable", "Impostor2.text")
    /// Impostor 2.0
    internal static let title = L10n.tr("Localizable", "Impostor2.title")
  }

  internal enum IncreaseContrast {
    /// Example of using the contrast tool. There are 6 images with increasing contrast. 
    internal static let example = L10n.tr("Localizable", "IncreaseContrast.example")
    /// Increase Contrast
    internal static let title = L10n.tr("Localizable", "IncreaseContrast.title")
    internal enum Intro {
      /// Another accessibility option the user can enable on the device's settings.
      internal static let text1 = L10n.tr("Localizable", "IncreaseContrast.Intro.text1")
      /// This one is also kinda obvious, the user is requesting to enhance contrast between foreground and background colors, so it gets easier to distinguish between them.
      internal static let text2 = L10n.tr("Localizable", "IncreaseContrast.Intro.text2")
    }
    internal enum Property {
      /// This app was built using system colors! Change the contrast options on your device's settings and check the differences!
      internal static let comment1 = L10n.tr("Localizable", "IncreaseContrast.Property.comment1")
      /// An easy way to support this is by using 'System Colors'. They will automatically adapt to the increase contrast.
      internal static let text1 = L10n.tr("Localizable", "IncreaseContrast.Property.text1")
      /// Or you can use the 'UIAccessibility.accessibilityDisplayShouldIncreaseContrast' boolean to check the current contrast state, and act accordingly.
      internal static let text2 = L10n.tr("Localizable", "IncreaseContrast.Property.text2")
      /// Handling contrast changes
      internal static let title = L10n.tr("Localizable", "IncreaseContrast.Property.title")
    }
    internal enum SwiftUI {
      /// Not that I have really used this contrast tool in any real project.
      internal static let comment1 = L10n.tr("Localizable", "IncreaseContrast.swiftUI.comment1")
      /// And in SwiftUI, there is a neat contrast tool you can use to change the contrast on your views
      internal static let text1 = L10n.tr("Localizable", "IncreaseContrast.swiftUI.text1")
    }
  }

  internal enum IncreasingHints {
    /// It's just so tiny... I don't remember what I had to say.
    internal static let hint1 = L10n.tr("Localizable", "IncreasingHints.hint1")
    /// The first hint needs to be a little bigger.
    internal static let hint2 = L10n.tr("Localizable", "IncreasingHints.hint2")
    /// The second number is 3, but maybe you can find another hints?
    internal static let hint3 = L10n.tr("Localizable", "IncreasingHints.hint3")
    /// The first number is 2 less than the second one.
    internal static let hint4 = L10n.tr("Localizable", "IncreasingHints.hint4")
    /// Getting big, aren't we? The last number is 4.
    internal static let hint5 = L10n.tr("Localizable", "IncreasingHints.hint5")
    /// The third number is the same as the first one.
    internal static let hint6 = L10n.tr("Localizable", "IncreasingHints.hint6")
    /// The fourth number is twice the second one.
    internal static let hint7 = L10n.tr("Localizable", "IncreasingHints.hint7")
    /// The missing number is the same as the last one!
    internal static let hint8 = L10n.tr("Localizable", "IncreasingHints.hint8")
    /// Can you read the hints? Use them to find the correct password.
    internal static let text = L10n.tr("Localizable", "IncreasingHints.text")
    /// Increasing hints
    internal static let title = L10n.tr("Localizable", "IncreasingHints.title")
    /// I'm super lost... I don't know what ot say.
    internal static let unspecified = L10n.tr("Localizable", "IncreasingHints.unspecified")
  }

  internal enum InvertColors {
    /// Invert Colors
    internal static let title = L10n.tr("Localizable", "InvertColors.title")
    internal enum Example {
      /// Only the second image is set to not invert colors.
      internal static let comment = L10n.tr("Localizable", "InvertColors.Example.comment")
      /// Starry night, by Van Gogh
      internal static let image1 = L10n.tr("Localizable", "InvertColors.Example.image1")
      /// Starry night, by Van Gogh. Image does not invert.
      internal static let image2 = L10n.tr("Localizable", "InvertColors.Example.image2")
      /// Change the display appearance from light/dark mode and the color inversion setting and check the images below.
      internal static let text1 = L10n.tr("Localizable", "InvertColors.Example.text1")
    }
    internal enum Intro {
      /// But why would anyone use this?
      internal static let comment1 = L10n.tr("Localizable", "InvertColors.Intro.comment1")
      /// Color Inversion is another accessibility option a user can enable on the device's settings.
      internal static let text1 = L10n.tr("Localizable", "InvertColors.Intro.text1")
      /// There are 2 types of color inversion:
      internal static let text2 = L10n.tr("Localizable", "InvertColors.Intro.text2")
      /// Classic - where everything will be inverted;
      internal static let text3 = L10n.tr("Localizable", "InvertColors.Intro.text3")
      /// Smart - where (almost) everything in light mode will be inverted, and you (the developer) can choose not to.
      internal static let text4 = L10n.tr("Localizable", "InvertColors.Intro.text4")
      /// I believe it comes down to difficulties in reading dark text on top of a white background. I myself, when I'm not using glasses, I find it pretty difficult to read content like this, so I preffer the dark mode, with white text on top of a dark background.
      internal static let text5 = L10n.tr("Localizable", "InvertColors.Intro.text5")
      /// The color inversion comes as an alternative to help you in this scenario.
      internal static let text6 = L10n.tr("Localizable", "InvertColors.Intro.text6")
    }
    internal enum WhatToDo {
      /// You basically need to mark what you don't want to be inverted. Like, images, a photo of your dog, a nice hamburguer that would look gross when inverted...
      internal static let text1 = L10n.tr("Localizable", "InvertColors.WhatToDo.text1")
      /// And to do so, you simply need to set a boolean telling you dont want this view to be inverted.
      internal static let text2 = L10n.tr("Localizable", "InvertColors.WhatToDo.text2")
      /// What to do as a developer?
      internal static let title = L10n.tr("Localizable", "InvertColors.WhatToDo.title")
    }
  }

  internal enum Invisibility {
    /// Wait... Is this content TRANSPARENT?
    internal static let comment = L10n.tr("Localizable", "Invisibility.comment")
    /// Just because you can't see, doens't mean it's not there.
    internal static let text = L10n.tr("Localizable", "Invisibility.text")
    /// Invisibility
    internal static let title = L10n.tr("Localizable", "Invisibility.title")
    /// Wait... Is this content TRANSPARENT?
    internal static let transparent = L10n.tr("Localizable", "Invisibility.transparent")
  }

  internal enum LearnAccessibility {
    /// Learn Accessibility
    internal static let title = L10n.tr("Localizable", "LearnAccessibility.title")
  }

  internal enum LearnTheFeatures {
    /// In order to make good questions, give better suggestions, integrate accessibility on your development...
    internal static let text1 = L10n.tr("Localizable", "LearnTheFeatures.text1")
    /// You need to learn what the accessibility features and options are, what difference they make on your app, how they impact your users, and most of all: How to use them.
    internal static let text2 = L10n.tr("Localizable", "LearnTheFeatures.text2")
    /// And this is your lucky day! Because this app not only contains guides on how to implement iOS accessibility options, but you can try them for yourself!
    internal static let text3 = L10n.tr("Localizable", "LearnTheFeatures.text3")
    /// Learn the Features
    internal static let title = L10n.tr("Localizable", "LearnTheFeatures.title")
    internal enum BeyondTheVoiceOver {
      /// Sometimes when talking about accessibility on mobile devices, we focus only on screen readers (on iOS, the VoiceOver).
      internal static let text1 = L10n.tr("Localizable", "LearnTheFeatures.BeyondTheVoiceOver.text1")
      /// But that's not what accessibility is about! There is an entire world of features, options, issues, disabilities, devices... that are part of accessibility.
      internal static let text2 = L10n.tr("Localizable", "LearnTheFeatures.BeyondTheVoiceOver.text2")
      /// And we also have guides on those!
      internal static let text3 = L10n.tr("Localizable", "LearnTheFeatures.BeyondTheVoiceOver.text3")
      /// Learn more about colors, motion, visual aids, fonts, haptics, contrast... and much more, so you know what to think and ask about.
      internal static let text4 = L10n.tr("Localizable", "LearnTheFeatures.BeyondTheVoiceOver.text4")
      /// Beyond The VoiceOver
      internal static let title = L10n.tr("Localizable", "LearnTheFeatures.BeyondTheVoiceOver.title")
    }
    internal enum VoiceOver {
      /// But, do you know what you can do with VoiceOver?
      internal static let comment1 = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.comment1")
      /// And make sure to try using the VoiceOver while reading the content so you can better understand what each element does.
      internal static let comment2 = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.comment2")
      /// Supporting VoiceOver use on your apps is usually what needs the most implementation and thought.
      internal static let text1 = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.text1")
      /// It's not only setting an 'accessibility label' into everything. We have different ways to group content, different ways to interact with elements and different ways to navigate through the app.
      internal static let text2 = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.text2")
      /// If you are not familiar with the VoiceOver, the concepts, the names, the gestures, take a look into our VoiceOver section on the Development Guides!
      internal static let text3 = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.text3")
      /// And if you want a "hand" to learn how to navigate using the VoiceOver, we have a gesture guide!
      internal static let text4 = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.text4")
      /// VoiceOver
      internal static let title = L10n.tr("Localizable", "LearnTheFeatures.VoiceOver.title")
    }
  }

  internal enum ListOfTraits {
    /// Allows gestures to update quantities. This is quite useful in some situations like quick-adds, sliders or counters!
    internal static let adjustable = L10n.tr("Localizable", "ListOfTraits.adjustable")
    /// The accessibility element allows direct touch interaction for VoiceOver users.
    internal static let allowsDirectInteraction = L10n.tr("Localizable", "ListOfTraits.allowsDirectInteraction")
    /// Tells that the item is a button - can be activated with a double tap.
    internal static let button = L10n.tr("Localizable", "ListOfTraits.button")
    /// Makes an automatic page turn when it finished reading the element.
    internal static let causesPageTurn = L10n.tr("Localizable", "ListOfTraits.causesPageTurn")
    /// Since I think they are the most important ones and I actually have something to talk about. (Or I just didn't have the time yet to write something nice about this trait)
    internal static let comment1 = L10n.tr("Localizable", "ListOfTraits.comment1")
    /// But make sure to check all of their documentations!
    internal static let comment2 = L10n.tr("Localizable", "ListOfTraits.comment2")
    /// A header that can be focused with rotor function. Indicates the begining of a new section.
    internal static let header = L10n.tr("Localizable", "ListOfTraits.header")
    /// An image. It may not seem, but its important to use when actually focusing on an image. The user may want to share the image with someone, or print screen it to ask more later...
    internal static let image = L10n.tr("Localizable", "ListOfTraits.image")
    /// A keyboard key. (Probably not very relevant if you are not creating a custom keyboard)
    internal static let keyboardKey = L10n.tr("Localizable", "ListOfTraits.keyboardKey")
    /// A link to a web page
    internal static let link = L10n.tr("Localizable", "ListOfTraits.link")
    /// The content interaction is disabled - eg: a disabled button
    internal static let notEnabled = L10n.tr("Localizable", "ListOfTraits.notEnabled")
    /// Plays sound when activated
    internal static let playsSound = L10n.tr("Localizable", "ListOfTraits.playsSound")
    /// Allows typing and when finished will search for something.
    internal static let searchField = L10n.tr("Localizable", "ListOfTraits.searchField")
    /// A selected item - used when there are more items on a list that can be selected as well (segmented controllers, radio buttons…)
    internal static let selected = L10n.tr("Localizable", "ListOfTraits.selected")
    /// Starts playing from a media session.
    internal static let startsMediaSession = L10n.tr("Localizable", "ListOfTraits.startsMediaSession")
    /// A text that does not change
    internal static let staticText = L10n.tr("Localizable", "ListOfTraits.staticText")
    /// "The accessibility element provides summary information when the app starts."
    internal static let summaryElement = L10n.tr("Localizable", "ListOfTraits.summaryElement")
    /// A tabbar item, actually very important if you have a custom tabbar!
    internal static let tabbar = L10n.tr("Localizable", "ListOfTraits.tabbar")
    /// Here's a full list of accessibility traits. Some of them are further discussed on this app
    internal static let text1 = L10n.tr("Localizable", "ListOfTraits.text1")
    /// Others are more obvious about how they should work, and where they should be used.
    internal static let text2 = L10n.tr("Localizable", "ListOfTraits.text2")
    /// List of Accessibility Traits
    internal static let title = L10n.tr("Localizable", "ListOfTraits.title")
    /// The value or label frequently changes.
    internal static let updatesFrequently = L10n.tr("Localizable", "ListOfTraits.updatesFrequently")
  }

  internal enum LongPress {
    /// Long press?
    internal static let comment1 = L10n.tr("Localizable", "LongPress.comment1")
    /// If you are using a long press gesture, I suggest always adding an accessibility hint to tell your user about it!
    internal static let comment2 = L10n.tr("Localizable", "LongPress.comment2")
    /// Long press is not an accessibility specific gesture, but I like to add it here because it has a specific gesture to be handled when using VoiceOver.
    internal static let text1 = L10n.tr("Localizable", "LongPress.text1")
    /// To simulate a Long Press you do a triple tap when focused on the item.
    internal static let text2 = L10n.tr("Localizable", "LongPress.text2")
    /// Turn VoiceOver on and focus on the next element. It has a long press gesture.
    internal static let text3 = L10n.tr("Localizable", "LongPress.text3")
    /// The long press is specially useful on 'Back buttons', which on newer iOS will display the navigation hierarchy, allowing you to easily navigate back to the page you want.
    internal static let text4 = L10n.tr("Localizable", "LongPress.text4")
    /// Long Press
    internal static let title = L10n.tr("Localizable", "LongPress.title")
    internal enum Code {
      /// Handle gesture
      internal static let comment = L10n.tr("Localizable", "LongPress.Code.comment")
    }
    internal enum Example {
      /// Tap three times to copy the text
      internal static let hint = L10n.tr("Localizable", "LongPress.Example.hint")
      /// Text copied to the clipboard
      internal static let notification = L10n.tr("Localizable", "LongPress.Example.notification")
      /// Some generic view in here
      internal static let text = L10n.tr("Localizable", "LongPress.Example.text")
    }
  }

  internal enum MagicTap {
    /// When implementing the 'Magic Tap', make sure it's enabled on the focused view, otherwise, it competes with the devices media player, because it's the same gesture to play/pause on the device.
    internal static let comment1 = L10n.tr("Localizable", "MagicTap.comment1")
    /// 'Magic Tap' is a double tap with two fingers gesture.
    internal static let text1 = L10n.tr("Localizable", "MagicTap.text1")
    /// You can configure the 'Magic Tap' to do basically anything.
    internal static let text2 = L10n.tr("Localizable", "MagicTap.text2")
    /// Apple's documentation suggests you use it to be a shortcut to 'your main action', such as a music player, it would be suited to play and pause actions, or on a camera app, it would be suited to take a photo.
    internal static let text3 = L10n.tr("Localizable", "MagicTap.text3")
    /// Test the Magic tap on the view below!
    internal static let text4 = L10n.tr("Localizable", "MagicTap.text4")
    /// Magic Tap
    internal static let title = L10n.tr("Localizable", "MagicTap.title")
    internal enum Example {
      /// Magic tap perfomed
      internal static let magicPerformed = L10n.tr("Localizable", "MagicTap.Example.magicPerformed")
      /// This content has a Magic Tap!
      internal static let thisContentIsMagic = L10n.tr("Localizable", "MagicTap.Example.thisContentIsMagic")
    }
  }

  internal enum MakingANewApp {
    /// Making a new app
    internal static let title = L10n.tr("Localizable", "MakingANewApp.title")
  }

  internal enum Modal {
    /// Modal views
    internal static let title = L10n.tr("Localizable", "Modal.title")
    internal enum Intro {
      /// But handling Modals has some differences in UIKit and SwiftUI, so I'm splitting into a section for each one here.
      internal static let comment1 = L10n.tr("Localizable", "Modal.Intro.comment1")
      /// Read more on reading order.
      internal static let link = L10n.tr("Localizable", "Modal.Intro.link")
      /// Modal Views, in this case, we are talking about any view that is displayed on top of existing content. Banners, toasts, floating buttons...
      internal static let text1 = L10n.tr("Localizable", "Modal.Intro.text1")
      /// The problem is: VoiceOver will try to use the language's Natural reading directions to read the content, and even if your view is on top of every other view, VoiceOver will still focus on the content behind it.
      internal static let text2 = L10n.tr("Localizable", "Modal.Intro.text2")
      /// To prevent this issue, we can mark a view as being a 'Modal'. This will make VoiceOver focus only on that view while it's being presented.
      internal static let text3 = L10n.tr("Localizable", "Modal.Intro.text3")
    }
    internal enum Example {
      /// Bad Modal
      internal static let badModal = L10n.tr("Localizable", "Modal.example.badModal")
      /// Noticed that when opening the good modal, the cursor focused directly on it? It is important when displaying a modal on top of existing content that we do that.
      internal static let comment = L10n.tr("Localizable", "Modal.example.comment")
      /// Good modal
      internal static let goodModal = L10n.tr("Localizable", "Modal.example.goodModal")
      /// Learn more about it on the Notifications section.
      internal static let link = L10n.tr("Localizable", "Modal.example.link")
      /// Turn VoiceOver on and test the modals below.
      internal static let text1 = L10n.tr("Localizable", "Modal.example.text1")
      /// This is a Bad modal
      internal static let thisBadModal = L10n.tr("Localizable", "Modal.example.thisBadModal")
      /// This is a Good modal
      internal static let thisGoodModal = L10n.tr("Localizable", "Modal.example.thisGoodModal")
    }
    internal enum Swiftui {
      /// On SwiftUI the 'Modal' can be set as it was an accessibility trait.
      internal static let text1 = L10n.tr("Localizable", "Modal.swiftui.text1")
    }
    internal enum Uikit {
      /// On UIKit, every UIView has the property 'accessibilityViewIsModal'. And we need to set it to 'True' if we want to mark a view as being a modal.
      internal static let text1 = L10n.tr("Localizable", "Modal.uikit.text1")
      /// But, on my experience, I find that simply setting it to 'True' sometimes does not have the expected behavior.
      internal static let text2 = L10n.tr("Localizable", "Modal.uikit.text2")
      /// I suggest overriding this property on the Modal View's class, and set it to the correct value.
      internal static let text3 = L10n.tr("Localizable", "Modal.uikit.text3")
    }
  }

  internal enum Navigation {
    /// This entire app was built to be used with VoiceOver enabled, the concept described on the pages will always be followed by an example so you can try them by yourself!
    internal static let comment = L10n.tr("Localizable", "Navigation.comment")
    /// Open the gestures guide.
    internal static let gesturesLink = L10n.tr("Localizable", "Navigation.gesturesLink")
    /// On top is an example of the cursor. The title 'Handbook' is currently focused on the image.
    internal static let image = L10n.tr("Localizable", "Navigation.image")
    /// Example image of VoiceOver running on an iOS device.
    internal static let imageSubtitle = L10n.tr("Localizable", "Navigation.imageSubtitle")
    /// VoiceOver navigation is based in gestures. Each gesture, can be perfomed anywhere on the screen, and will trigger a certain action.
    internal static let text1 = L10n.tr("Localizable", "Navigation.text1")
    /// Once enabled, VoiceOver will display a frame on top of the current view that is being read. This frame is called 'Cursor'.
    internal static let text2 = L10n.tr("Localizable", "Navigation.text2")
    /// To navigate basically means changing the cursor's position, so it will read another element.
    internal static let text3 = L10n.tr("Localizable", "Navigation.text3")
    /// The basic navigation can be done swiping horizontally on the screen to move to cursor to the next or previous element.
    internal static let text4 = L10n.tr("Localizable", "Navigation.text4")
    /// Navigation
    internal static let title = L10n.tr("Localizable", "Navigation.title")
    internal enum Activate {
      /// You can learn more about ways to interact with elements on the 'Interaction' section
      internal static let comment = L10n.tr("Localizable", "Navigation.Activate.comment")
      /// Activate, is VoiceOver version of tapping an item. Double tap with a single finger to activate an element.
      internal static let text = L10n.tr("Localizable", "Navigation.Activate.text")
      /// Activate an element
      internal static let title = L10n.tr("Localizable", "Navigation.Activate.title")
    }
    internal enum Footer {
      /// These are just a few of the gestures available. We plan on adding a full gesture section in the future, but for now, I suggest you try it for yourself, turn VoiceOver on and test the gestures using the 'Gesture Help'.
      internal static let comment = L10n.tr("Localizable", "Navigation.Footer.comment")
      /// If you tap with 4 fingers twice with VoiceOver enabled, you will activate the 'Gesture Helper'.
      internal static let text1 = L10n.tr("Localizable", "Navigation.Footer.text1")
      /// Now, every gesture you make will be announced by VoiceOver, followed by it's function.
      internal static let text2 = L10n.tr("Localizable", "Navigation.Footer.text2")
      /// And to disable the helper, tap twice with 4 fiongers again!
      internal static let text3 = L10n.tr("Localizable", "Navigation.Footer.text3")
      /// Learn more gestures
      internal static let title = L10n.tr("Localizable", "Navigation.Footer.title")
    }
    internal enum MoveAround {
      /// When VoiceOver is enabled, swipe horizontally from left to right to move the cursor to focus on the next element.
      internal static let text1 = L10n.tr("Localizable", "Navigation.MoveAround.text1")
      /// And swipe from right to left to focus on the previous element.
      internal static let text2 = L10n.tr("Localizable", "Navigation.MoveAround.text2")
      /// Move Around
      internal static let title = L10n.tr("Localizable", "Navigation.MoveAround.title")
    }
  }

  internal enum NotifyChanges {
    /// But what is the argument that is 'nil' on the code?
    internal static let comment1 = L10n.tr("Localizable", "NotifyChanges.comment1")
    /// Find out more about it on the following page!
    internal static let comment2 = L10n.tr("Localizable", "NotifyChanges.comment2")
    /// Layout change notification
    internal static let layoutChange = L10n.tr("Localizable", "NotifyChanges.layoutChange")
    /// Screen change notification
    internal static let screenChange = L10n.tr("Localizable", "NotifyChanges.screenChange")
    /// When something changes on the screen, we need to remember a VoiceOver user will not be able to see it.
    internal static let text1 = L10n.tr("Localizable", "NotifyChanges.text1")
    /// This is also valid to when the screen itself changes.
    internal static let text2 = L10n.tr("Localizable", "NotifyChanges.text2")
    /// But, we have some Accessibility Notifications that behave like audio cues to tell the user something has happened.
    internal static let text3 = L10n.tr("Localizable", "NotifyChanges.text3")
    /// Notify Screen changes
    internal static let title = L10n.tr("Localizable", "NotifyChanges.title")
  }

  internal enum PreferCrossFadePage {
    /// This app uses a default navigation stack. Go to settings and change this accessibility option, then come back and try opening new scenes or going back to previous ones. The default slide transition should be replaced with cross-fades.
    internal static let comment1 = L10n.tr("Localizable", "PreferCrossFadePage.comment1")
    /// When enabled, this also means 'Reduce Motion' is also enabled.
    internal static let comment2 = L10n.tr("Localizable", "PreferCrossFadePage.comment2")
    /// This is an additional option inside the 'Reduce Motion' on the device's settings.
    internal static let text1 = L10n.tr("Localizable", "PreferCrossFadePage.text1")
    /// When enabled, screen transitions should be reduced to a cross-fade animation instead of sliding-in.
    internal static let text2 = L10n.tr("Localizable", "PreferCrossFadePage.text2")
    /// This will also change the default behavior for NavigationViews and NavigationStacks, without additional code necessary.
    internal static let text3 = L10n.tr("Localizable", "PreferCrossFadePage.text3")
    /// You can also check if this feature is enabled to make manual adjustments.
    internal static let text4 = L10n.tr("Localizable", "PreferCrossFadePage.text4")
    /// Prefers cross-fade transitions
    internal static let title = L10n.tr("Localizable", "PreferCrossFadePage.title")
  }

  internal enum ReduceMotion {
    /// The example above used a 3D animation to flip the card when tapped. This is a fine example of animations that should be disabled.
    internal static let cardFlip = L10n.tr("Localizable", "ReduceMotion.cardFlip")
    /// It's also a nice example to use Custom Actions for screen reader accessibility!
    internal static let cardFlip2 = L10n.tr("Localizable", "ReduceMotion.cardFlip2")
    /// Small animations can be disabled as well, but they are not required to. As a general guide, we'd like to disable them as well.
    internal static let simpleAppearance = L10n.tr("Localizable", "ReduceMotion.simpleAppearance")
    /// Reduce Motion
    internal static let title = L10n.tr("Localizable", "ReduceMotion.title")
    internal enum Disclaimer {
      /// But as an overall guideline, we should usually disable all custom animations on views, parallax effects, and additional screen transitions.
      internal static let comment1 = L10n.tr("Localizable", "ReduceMotion.Disclaimer.comment1")
      /// Apple's documentation suggests that if this property is 'True' UI should avoid large animations, especially those that simulate the third dimension.
      internal static let text1 = L10n.tr("Localizable", "ReduceMotion.Disclaimer.text1")
      /// Go to settings and change the reduce motion option, then, check the examples below.
      internal static let text2 = L10n.tr("Localizable", "ReduceMotion.Disclaimer.text2")
    }
    internal enum Intro {
      /// Sometimes, we add moving items to our views. They may be some cool way to visualize something, an animation to present an item, a nice screen transition, or anything else at all.
      internal static let text1 = L10n.tr("Localizable", "ReduceMotion.Intro.text1")
      /// The problem is: Some people may feel discomfort when observing these animations, due to motion sickness or similar issues.
      internal static let text2 = L10n.tr("Localizable", "ReduceMotion.Intro.text2")
      /// That's why iOS systems have a a built in feature that allows users to request for reduced animations while using applications.
      internal static let text3 = L10n.tr("Localizable", "ReduceMotion.Intro.text3")
    }
    internal enum SimpleAppearance {
      /// Open more actions
      internal static let text = L10n.tr("Localizable", "ReduceMotion.simpleAppearance.text")
    }
  }

  internal enum ReduceTransparency {
    /// Reduce Transparency
    internal static let title = L10n.tr("Localizable", "ReduceTransparency.title")
    internal enum Code {
      /// And, it's pretty easy to handle!
      internal static let text1 = L10n.tr("Localizable", "ReduceTransparency.Code.text1")
      /// On UIKit, you need to check a boolean on UIAccessibility to check if the feature is enabled.
      internal static let text2 = L10n.tr("Localizable", "ReduceTransparency.Code.text2")
      /// And you can alo subscribe to listen to changes in this property using the Notification Center.
      internal static let text3 = L10n.tr("Localizable", "ReduceTransparency.Code.text3")
      /// And on SwiftUI you can use an Environment variable!
      internal static let text4 = L10n.tr("Localizable", "ReduceTransparency.Code.text4")
    }
    internal enum Example {
      /// Transparent content to be read\non top of a blured background
      internal static let example = L10n.tr("Localizable", "ReduceTransparency.Example.example")
      /// Try enabling and disabling this option and check the content below.
      internal static let text1 = L10n.tr("Localizable", "ReduceTransparency.Example.text1")
    }
    internal enum Intro {
      /// Some poeple may have a hard time looking into translucent elements!
      internal static let comment = L10n.tr("Localizable", "ReduceTransparency.Intro.comment")
      /// This is an accessibility option that needs to be enabled on the Device's settings.
      internal static let text1 = L10n.tr("Localizable", "ReduceTransparency.Intro.text1")
      /// When enabled, the user want's to tell you they want to reduce the amount of blur and translucency on the app.
      internal static let text2 = L10n.tr("Localizable", "ReduceTransparency.Intro.text2")
    }
  }

  internal enum Rotor {
    /// The Rotor is one of those things I think not everybody knows about.
    internal static let comment1 = L10n.tr("Localizable", "Rotor.comment1")
    /// Turn VoiceOver on and try it for yourself!
    internal static let comment2 = L10n.tr("Localizable", "Rotor.comment2")
    /// Use the page below to test using Custom rotor items!
    internal static let comment3 = L10n.tr("Localizable", "Rotor.comment3")
    /// Rotor example image
    internal static let image = L10n.tr("Localizable", "Rotor.image")
    /// Open example page with custom Rotors.
    internal static let openExample = L10n.tr("Localizable", "Rotor.openExample")
    /// If you do the gesture of a circle with 2 fingers on the screen, you will enable the rotor.
    internal static let text1 = L10n.tr("Localizable", "Rotor.text1")
    /// The rotor has some default actions to it like changing the speaking rate or VoiceOver's language.
    internal static let text2 = L10n.tr("Localizable", "Rotor.text2")
    /// You can also create custom actions to the rotor. The idea is to use it to help users find specific content, like filtering for links, or any other similar elements.
    internal static let text3 = L10n.tr("Localizable", "Rotor.text3")
  }

  internal enum RotorAndHeaders {
    /// Rotor and Headers
    internal static let title = L10n.tr("Localizable", "RotorAndHeaders.title")
    internal enum Example {
      /// If you haven't noticed, this page was built using some headers!
      internal static let text1 = L10n.tr("Localizable", "RotorAndHeaders.Example.text1")
      /// Turn on VoiceOver and try to navigate only on them!
      internal static let text2 = L10n.tr("Localizable", "RotorAndHeaders.Example.text2")
    }
    internal enum Header {
      /// The accessibility trait 'header' is important to mark the beggining of a new content section, but also its important to notice how it affects the user's navigation with the Rotor.
      internal static let text1 = L10n.tr("Localizable", "RotorAndHeaders.Header.text1")
      /// If you haven't seen the 'Header Trait page', take a look to leanr more about it!
      internal static let text2 = L10n.tr("Localizable", "RotorAndHeaders.Header.text2")
    }
    internal enum Rotor {
      /// If you haven't seen it yet, check our Rotor page to learn more about this component!
      internal static let text = L10n.tr("Localizable", "RotorAndHeaders.Rotor.text")
    }
    internal enum Together {
      /// If you enable the rotor, you may notice it has the 'Header' options
      internal static let text1 = L10n.tr("Localizable", "RotorAndHeaders.Together.text1")
      /// When selected, this option will allow you to navigate only on headers by swiping up and down on your device.
      internal static let text2 = L10n.tr("Localizable", "RotorAndHeaders.Together.text2")
      /// This is extremely useful to find specific content among many other things.
      internal static let text3 = L10n.tr("Localizable", "RotorAndHeaders.Together.text3")
      /// What about them together?
      internal static let title = L10n.tr("Localizable", "RotorAndHeaders.Together.title")
    }
  }

  internal enum RotorExample {
    /// History
    internal static let history = L10n.tr("Localizable", "RotorExample.history")
    /// Vincent Van Gogh was a Dutch painter born in March 1853. He's considered one of the most influential painters in all history, although, this recognition only came after his death.
    internal static let history1 = L10n.tr("Localizable", "RotorExample.history1")
    /// He did not start his life as a painter, and only started painting around 1880. And was introduced in Paris to the "Impressioninsm".
    internal static let history2 = L10n.tr("Localizable", "RotorExample.history2")
    /// One of his paintings 'The Starry Night', was painted around 1889, is today one of the most famous paintings in the entire world.
    internal static let history3 = L10n.tr("Localizable", "RotorExample.history3")
    /// And another famous paintings, are the series of 'Sunflowers'. Two collection of paintings depicting sunflowers, and recognized by style and bright colors.
    internal static let history4 = L10n.tr("Localizable", "RotorExample.history4")
    /// Images
    internal static let images = L10n.tr("Localizable", "RotorExample.images")
    /// Impressionism
    internal static let link1 = L10n.tr("Localizable", "RotorExample.link1")
    /// The Starry Night
    internal static let link2 = L10n.tr("Localizable", "RotorExample.link2")
    /// Sunflowers
    internal static let link3 = L10n.tr("Localizable", "RotorExample.link3")
    /// Links
    internal static let links = L10n.tr("Localizable", "RotorExample.links")
    /// Impressionism is the name of a 19th century artistic movement. In painting, characterized by relatively small, thin, yet visible brush strokes, open composition, emphasis on accurate depiction of light in its changing qualities, ordinary subject matter, unusual visual angles, and inclusion of movement as a crucial element of human perception and experience.
    internal static let note1 = L10n.tr("Localizable", "RotorExample.note1")
    /// It depicts the view from the east-facing window of his asylum room at Saint-Rémy-de-Provence, just before sunrise, with the addition of an imaginary village.
    internal static let note2 = L10n.tr("Localizable", "RotorExample.note2")
    /// The first series, executed in Paris in 1887, depicts the flowers lying on the ground, while the second set, made a year later in Arles, shows a bouquet of sunflowers in a vase.
    internal static let note3 = L10n.tr("Localizable", "RotorExample.note3")
    /// Notes
    internal static let notes = L10n.tr("Localizable", "RotorExample.notes")
    /// Starry night, by Vincent Van Ghog.
    internal static let starryNight = L10n.tr("Localizable", "RotorExample.starryNight")
    /// Sunflower, by Vincent Van Gogh.
    internal static let sunflower = L10n.tr("Localizable", "RotorExample.sunflower")
    /// This page contains custom rotor items: Images, Notes, History and Links
    internal static let text1 = L10n.tr("Localizable", "RotorExample.text1")
    /// Select the desired option on the Rotor, then, swipe up and down to select only the desired content.
    internal static let text2 = L10n.tr("Localizable", "RotorExample.text2")
    /// This is a nice example on how to use rotors to provide easier ways to filter and find content.
    internal static let text3 = L10n.tr("Localizable", "RotorExample.text3")
    /// Rotor Example
    internal static let title = L10n.tr("Localizable", "RotorExample.title")
    /// Van Gogh
    internal static let vanGogh = L10n.tr("Localizable", "RotorExample.vanGogh")
    /// Self portrait, by Vincent Van Gogh.
    internal static let vanGoghImage = L10n.tr("Localizable", "RotorExample.vanGoghImage")
  }

  internal enum Search {
    internal enum Empty {
      /// Search all pages
      internal static let action = L10n.tr("Localizable", "Search.Empty.action")
      /// Try changing your search!
      internal static let message = L10n.tr("Localizable", "Search.Empty.message")
      /// No results could be found
      internal static let title = L10n.tr("Localizable", "Search.Empty.title")
    }
  }

  internal enum SearchFieldTrait {
    /// Try here!
    internal static let button = L10n.tr("Localizable", "SearchFieldTrait.button")
    /// Type what you are searching for.
    internal static let description = L10n.tr("Localizable", "SearchFieldTrait.description")
    /// The Search Field Trait is good for fields that are not just data inputs, but also performs some visual change on the screen when filled.
    internal static let text1 = L10n.tr("Localizable", "SearchFieldTrait.text1")
    /// When we search for something, normally these searches results are displayed somewhere on the screen.
    internal static let text2 = L10n.tr("Localizable", "SearchFieldTrait.text2")
    /// This trait allows VoiceOver to warn the user that the UI will change somewhere.
    internal static let text3 = L10n.tr("Localizable", "SearchFieldTrait.text3")
    /// Search Field Trait
    internal static let title = L10n.tr("Localizable", "SearchFieldTrait.title")
    internal enum AnimalsArray {
      /// 🐝 Bee
      internal static let bee = L10n.tr("Localizable", "SearchFieldTrait.AnimalsArray.Bee")
      /// 🦜 Bird
      internal static let bird = L10n.tr("Localizable", "SearchFieldTrait.AnimalsArray.Bird")
      /// 🐈 Cat
      internal static let cat = L10n.tr("Localizable", "SearchFieldTrait.AnimalsArray.Cat")
      /// 🐄 Cow
      internal static let cow = L10n.tr("Localizable", "SearchFieldTrait.AnimalsArray.Cow")
      /// 🐶 Dog
      internal static let dog = L10n.tr("Localizable", "SearchFieldTrait.AnimalsArray.Dog")
      /// 🐍 Snake
      internal static let snake = L10n.tr("Localizable", "SearchFieldTrait.AnimalsArray.Snake")
    }
  }

  internal enum SecretActions {
    /// Don't worry, they'll tell you what they like.
    internal static let comment = L10n.tr("Localizable", "SecretActions.comment")
    /// Feed each animal the correct food!
    internal static let text = L10n.tr("Localizable", "SecretActions.text")
    /// Secret Actions
    internal static let title = L10n.tr("Localizable", "SecretActions.title")
    internal enum Action {
      /// Give Apples
      internal static let apples = L10n.tr("Localizable", "SecretActions.Action.apples")
      /// Give Bubbles
      internal static let bubbles = L10n.tr("Localizable", "SecretActions.Action.bubbles")
      /// Give Grass
      internal static let grass = L10n.tr("Localizable", "SecretActions.Action.grass")
      /// Give Nectar
      internal static let nectar = L10n.tr("Localizable", "SecretActions.Action.nectar")
    }
  }

  internal enum SizeAndWeight {
    /// Size and Weight
    internal static let title = L10n.tr("Localizable", "SizeAndWeight.title")
  }

  internal enum SummaryElementTrait {
    /// This screen is about summary element traits
    internal static let description = L10n.tr("Localizable", "SummaryElementTrait.description")
    /// The Summary Element Trait gives a summarized description of the most important info of the screen.
    internal static let text1 = L10n.tr("Localizable", "SummaryElementTrait.text1")
    /// An example is Apple's Weather app, in which the view that contains the city and current weather is used as a summary.
    internal static let text2 = L10n.tr("Localizable", "SummaryElementTrait.text2")
    /// This trait makes VoiceOver read this element as soon as the screen appears, regardless of the position of this element in the view hierarchy. The focus order is not affected.
    internal static let text3 = L10n.tr("Localizable", "SummaryElementTrait.text3")
    /// Summary Element Trait
    internal static let title = L10n.tr("Localizable", "SummaryElementTrait.title")
  }

  internal enum SuperFriend {
    /// Find the person with the biggest amount of friends!
    internal static let comment = L10n.tr("Localizable", "SuperFriend.comment")
    /// Super Friend name
    internal static let field = L10n.tr("Localizable", "SuperFriend.field")
    /// Everyone here is so friendly,
    internal static let text = L10n.tr("Localizable", "SuperFriend.text")
    /// Super Friend
    internal static let title = L10n.tr("Localizable", "SuperFriend.title")
  }

  internal enum TeamGame {
    /// Bear with me! 🐻
    internal static let comment1 = L10n.tr("Localizable", "TeamGame.comment1")
    /// While learning accessibility by yourself feels good, it feels good to be able to reach people you could not before, it fells good to provide new services and content to a whole new group of people, you are most likely not going to handle it on your own.
    internal static let text1 = L10n.tr("Localizable", "TeamGame.text1")
    /// If you work on a company, on a startup, or you made a new app project with some friends, you know that creating a new app is not an easy task.
    internal static let text2 = L10n.tr("Localizable", "TeamGame.text2")
    /// And accessibility is not a developer or designer specific job. It's easy to think\n\n"Oh, our designer should have figured that!"\n\nOr even,\n\n"Accessibility? That's a job for our developers!"
    internal static let text3 = L10n.tr("Localizable", "TeamGame.text3")
    /// Think of it as part of your culture. Everybody should understand and question how accessibility should work.
    internal static let text4 = L10n.tr("Localizable", "TeamGame.text4")
    /// This way, we can make sure that we have the right questions and issues being tackled on every aspect of your application, on design, development, product... everything!
    internal static let text5 = L10n.tr("Localizable", "TeamGame.text5")
    /// Accessibility is a team game
    internal static let title = L10n.tr("Localizable", "TeamGame.title")
    internal enum ShareTheKnowledge {
      /// And that goes for everything, not only accessibility!
      internal static let comment1 = L10n.tr("Localizable", "TeamGame.ShareTheKnowledge.comment1")
      /// Show to your peers whenever you create something nice, when you use a new feature that you have never used before.
      internal static let text1 = L10n.tr("Localizable", "TeamGame.ShareTheKnowledge.text1")
      /// Spreading knowledge will help more people to know about it, and give them and yourself more tools to work with in the future.
      internal static let text2 = L10n.tr("Localizable", "TeamGame.ShareTheKnowledge.text2")
      /// And if you are using this app, you can even use the neat share tool on top of every page to bring people directly into an example of what you are talking about!
      internal static let text3 = L10n.tr("Localizable", "TeamGame.ShareTheKnowledge.text3")
      /// Share the knowledge
      internal static let title = L10n.tr("Localizable", "TeamGame.ShareTheKnowledge.title")
    }
    internal enum TalkToYourTeam {
      /// I know this sound a little like coaching, sorry about that, but it's important.
      internal static let comment1 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.comment1")
      /// I'm not a designer nor a specialist myself, I'm more of an enthusiast.
      internal static let comment2 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.comment2")
      /// What was the last time you asked your designer "Have you thought about how to interact with this element with a screen reader?"
      internal static let text1 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text1")
      /// Or what was the last time you asked your developer "How can we make this component have a better interaction when using accessibility features?"
      internal static let text2 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text2")
      /// By asking questions, you are bringing the discussion about accessibility into your daily work.
      internal static let text3 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text3")
      /// "This font seems small, do we have support for dynamic fonts?"
      internal static let text4 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text4")
      /// "The contrast does not seem good, have we checked for colorblindness? Do we have support for a increased contrast color pallet?"
      internal static let text5 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text5")
      /// Make questions. Usually, nobody is a specialist in accessibility, maybe someone knows more about a different platform than the one you are working with, and you can try connecting this knowledge with your current work.
      internal static let text6 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text6")
      /// But to make good questions, and give nice suggestions, you need to understand more what are you really working with.
      internal static let text7 = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.text7")
      /// Talk to your team
      internal static let title = L10n.tr("Localizable", "TeamGame.TalkToYourTeam.title")
    }
  }

  internal enum TheMagicPuzzle {
    /// I don't know what else to tell you...
    internal static let comment = L10n.tr("Localizable", "TheMagicPuzzle.comment")
    /// This puzzle is Magic!
    internal static let text = L10n.tr("Localizable", "TheMagicPuzzle.text")
    /// The 'Magic' Puzzle
    internal static let title = L10n.tr("Localizable", "TheMagicPuzzle.title")
  }

  internal enum TheUpsideDown {
    /// Maybe there is a way to see it.
    internal static let text1 = L10n.tr("Localizable", "TheUpsideDown.text1")
    /// I feel so inverted
    internal static let text2 = L10n.tr("Localizable", "TheUpsideDown.text2")
    /// The Upside Down
    internal static let title = L10n.tr("Localizable", "TheUpsideDown.title")
  }

  internal enum ThinkingAccessibility {
    /// The idea is to help you "think accessibility", understand common pitfalls and start a new project having a good idea of what you should expect when creating an iOS application.
    internal static let comment1 = L10n.tr("Localizable", "ThinkingAccessibility.comment1")
    /// So, sit tight! If you are new on the iOS accessibility world, this is going to be a wild ride!
    internal static let comment2 = L10n.tr("Localizable", "ThinkingAccessibility.comment2")
    /// This section is a different type of guide, where we want to show you how to think about accessibility while developing or creating new applications.
    internal static let text1 = L10n.tr("Localizable", "ThinkingAccessibility.text1")
    /// Accessibility is one of those things that if you say: "I want to improve accessibility on our app!", nobody is going to say no.
    internal static let text2 = L10n.tr("Localizable", "ThinkingAccessibility.text2")
    /// But it can get hard to start making these improvements and see a real impact to your users.
    internal static let text3 = L10n.tr("Localizable", "ThinkingAccessibility.text3")
    /// Or maybe you are starting a new app and you want to give support to accessibility features from the begining.
    internal static let text4 = L10n.tr("Localizable", "ThinkingAccessibility.text4")
    /// So, we are bringing a content based on real life experiences, alongside the common guide for all the accessibility options and features, to help you not only learn what they are, but the best scenarios to use them.
    internal static let text5 = L10n.tr("Localizable", "ThinkingAccessibility.text5")
    /// Welcome, to the Accessibility Handbook classes!
    internal static let text6 = L10n.tr("Localizable", "ThinkingAccessibility.text6")
    /// Thinking Accessibility
    internal static let title = L10n.tr("Localizable", "ThinkingAccessibility.title")
  }

  internal enum TintableImages {
    /// Providing images for different appearances
    internal static let doc = L10n.tr("Localizable", "TintableImages.doc")
    /// Tintable images
    internal static let title = L10n.tr("Localizable", "TintableImages.title")
    internal enum Example {
      /// The image above was built using a template image. When no tint color is provided, it's going to use the default color for the image. This is a good approach for icons you may have on your UI.
      internal static let text1 = L10n.tr("Localizable", "TintableImages.Example.text1")
      /// But you can specify custom tint colors. Remember to keep these colors also adapted to each color scheme available.
      internal static let text2 = L10n.tr("Localizable", "TintableImages.Example.text2")
      /// And if you haven't set the asset as a 'template image' on the XCTAssets, you can force the template on code as well.
      internal static let text3 = L10n.tr("Localizable", "TintableImages.Example.text3")
    }
    internal enum TintableImages {
      /// When you add a template image to a button or image view, you also specify a tint color. The view applies the tint color to every pixel that doesn’t have an alpha of 0.0, causing the image’s shape to adopt that color. To support different appearances, simply change the tint color. For example, you might apply a dark tint color in light environments and a light tint color in dark environments.
      internal static let citation1 = L10n.tr("Localizable", "TintableImages.TintableImages.citation1")
      /// When creating your image, use a transparent background and add black pixels wherever you want the image to appear. The pixels can be fully or partially opaque, depending on whether you want portions of your template image to blend with the background colors. When adding the image to your asset catalog, set the Render As option for the Image Set asset to Template Image in the inspector.
      internal static let citation2 = L10n.tr("Localizable", "TintableImages.TintableImages.citation2")
      /// You don't necessarily need to have different assets for different color schemes. One thing you can use with XCAssets are tintable images. It means adding the image as a template, and defining it's color later.
      internal static let text1 = L10n.tr("Localizable", "TintableImages.TintableImages.text1")
      /// From Apple's documentation:
      internal static let text2 = L10n.tr("Localizable", "TintableImages.TintableImages.text2")
    }
  }

  internal enum TryItYourself {
    /// What was the last time you ran your app with the VoiceOver running? Or that you tried to increase your fonts to see how your layout behaves?
    internal static let comment1 = L10n.tr("Localizable", "TryItYourself.comment1")
    /// Yep, thats it, try it for yourself!
    internal static let text1 = L10n.tr("Localizable", "TryItYourself.text1")
    /// Try not to keep wat you learn here only on this app. Start a new app, try implementing dynamic fonts, VoiceOver features, Dark mode, Rotor entries...
    internal static let text2 = L10n.tr("Localizable", "TryItYourself.text2")
    /// Understand what they do, how they impact your code, and how to use them.
    internal static let text3 = L10n.tr("Localizable", "TryItYourself.text3")
    /// We even have hundreds of code examples to help you get started. But they are only examples.
    internal static let text4 = L10n.tr("Localizable", "TryItYourself.text4")
    /// You'll get it for yourself once you really start introducing these featuers on your code and your app.
    internal static let text5 = L10n.tr("Localizable", "TryItYourself.text5")
    /// And also, try running everything on a real device. Get the feel of how things work in the real life, out of Xcode.
    internal static let text6 = L10n.tr("Localizable", "TryItYourself.text6")
    /// The next sections, will introduce you to issues and common uses of accessibility. How to implement them, and how to plan to create more accessible apps.
    internal static let text7 = L10n.tr("Localizable", "TryItYourself.text7")
    /// Don't give up! We are just starting 😉
    internal static let text8 = L10n.tr("Localizable", "TryItYourself.text8")
    /// Try it yourself
    internal static let title = L10n.tr("Localizable", "TryItYourself.title")
  }

  internal enum UIContentSizeCategory {
    /// UIContentSizeCategory
    internal static let title = L10n.tr("Localizable", "UIContentSizeCategory.title")
    internal enum Code {
      /// You can check the system's font size by using the following code.
      internal static let text1 = L10n.tr("Localizable", "UIContentSizeCategory.Code.text1")
    }
    internal enum Intro {
      /// The accessibility sizes are larger than the other ones, even if their name starts at 'accessibility medium' it's still larger than the regular 'extra extra extra large' size.
      internal static let comment1 = L10n.tr("Localizable", "UIContentSizeCategory.Intro.comment1")
      /// The 'UIContentSizeCategory' is a system enum that represents the user's selected preferred content size.
      internal static let text1 = L10n.tr("Localizable", "UIContentSizeCategory.Intro.text1")
      /// It has 12 different size options from extra small to extra extra extra large, then the 'accessibility sizes' from accessibility medium to accessibility extra extra extra large. (Yep, 3 extras)
      internal static let text2 = L10n.tr("Localizable", "UIContentSizeCategory.Intro.text2")
    }
    internal enum List {
      /// Although, on code, usually you should not check this information directly and just use the UIFontMetric or system fonts to scale your font to the correct size.
      internal static let comment1 = L10n.tr("Localizable", "UIContentSizeCategory.List.comment1")
      /// This is your current content size.
      internal static let current = L10n.tr("Localizable", "UIContentSizeCategory.List.current")
      /// Here's a list of all the available content size categories. You can check the 'Identify preferred content size' page to get more information on how to properly identify them.
      internal static let text1 = L10n.tr("Localizable", "UIContentSizeCategory.List.text1")
      /// List of UIContentSizeCategory
      internal static let title = L10n.tr("Localizable", "UIContentSizeCategory.List.title")
    }
  }

  internal enum UIFontMetrics {
    /// UIFontMetrics
    internal static let title = L10n.tr("Localizable", "UIFontMetrics.title")
    internal enum Intro {
      /// Make sure your font looks good in bigger and smaller sizes! Readability is they key in every font size.
      internal static let comment1 = L10n.tr("Localizable", "UIFontMetrics.Intro.comment1")
      /// UIFontMetrics is the solution to support scaling custom fonts automatically. You create a font metrics object that specifies the font style that you want to use in your app.
      internal static let text1 = L10n.tr("Localizable", "UIFontMetrics.Intro.text1")
      /// Then, you load your custom font and scale it using the UIFontMetrics.
      internal static let text2 = L10n.tr("Localizable", "UIFontMetrics.Intro.text2")
    }
  }

  internal enum WhatIsDarkMode {
    /// What is dark mode?
    internal static let title = L10n.tr("Localizable", "WhatIsDarkMode.title")
    internal enum DoINeedIt {
      /// Sometimes, your interface does not need to support dark mode. Maybe it's a game and the colors have been specifically chosen for it, or the content's color take a bigger part in what your app does, so supporting dark mode is not an option.
      internal static let text1 = L10n.tr("Localizable", "WhatIsDarkMode.DoINeedIt.text1")
      /// But when we are talking about apps that are mostly written content, so the user needs to read a lot of things while using the application, or use some shade of white as the default background color, these are good examples of apps that should support dark mode.
      internal static let text2 = L10n.tr("Localizable", "WhatIsDarkMode.DoINeedIt.text2")
      /// Maybe to give the aesthetic choice, but also to support those who prefer the dark mode to read the content.
      internal static let text3 = L10n.tr("Localizable", "WhatIsDarkMode.DoINeedIt.text3")
      /// Do I need to support dark mode?
      internal static let title = L10n.tr("Localizable", "WhatIsDarkMode.DoINeedIt.title")
    }
    internal enum Intro {
      /// The existence of a dark mode also implies the existence of a light mode, which is the opposite use of colors - light background and dark content.
      internal static let comment1 = L10n.tr("Localizable", "WhatIsDarkMode.Intro.comment1")
      /// You can read more on the 'Invert colors' page for more insights into different content colors.
      internal static let comment2 = L10n.tr("Localizable", "WhatIsDarkMode.Intro.comment2")
      /// Dark mode is the ability to change the interface to a darker appearance. Where, usually, the background consists in darker colors and written content in lighter colors.
      internal static let text1 = L10n.tr("Localizable", "WhatIsDarkMode.Intro.text1")
      /// It is, sometimes, an aesthetic preference for the user. In MacOS it can be even automatically set to change on specific ambient or lighting conditions.
      internal static let text2 = L10n.tr("Localizable", "WhatIsDarkMode.Intro.text2")
      /// But the deal here is that supporting dark mode can be a form of accessibility. The user can prefer using it for any reason, reading light content maybe feels better on top of a dark background, specially on low-light environments, or just felling more comfortable with less light comming from the device.
      internal static let text3 = L10n.tr("Localizable", "WhatIsDarkMode.Intro.text3")
    }
    internal enum ThisAppSupports {
      /// Command + shift + A
      internal static let command = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.command")
      /// I strongly suggest reading the content on the Apple's 'Human Interface Guidelines' about Dark Mode.
      internal static let comment1 = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.comment1")
      /// Example of the Control center menu after long pressing the displays brightness options.
      internal static let image = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.image")
      /// The Accessibility Handbook fully supports dark mode. If you are using and iOS device, you can change you appearance on the system's settings.
      internal static let text1 = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.text1")
      /// Or use the Control center menu (the system's pull down menu) as a shortcut, by long pressing the display brightness option, and it will display a control to select between light and dark modes.
      internal static let text2 = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.text2")
      /// And if you are running this on an iOS simulator on a Mac, you can quickly change the appearance option with the keyboard command.
      internal static let text3 = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.text3")
      /// This app supports dark mode!
      internal static let title = L10n.tr("Localizable", "WhatIsDarkMode.ThisAppSupports.title")
    }
  }

  internal enum WhatsNew {
    /// Current Version %@
    internal static func currentVersion(_ p1: Any) -> String {
      return L10n.tr("Localizable", "WhatsNew.currentVersion", String(describing: p1))
    }
    /// See the release notes on GitHub for version %@
    internal static func seeTheReleaseNotes(_ p1: Any) -> String {
      return L10n.tr("Localizable", "WhatsNew.seeTheReleaseNotes", String(describing: p1))
    }
    /// What's new on the app?
    internal static let title = L10n.tr("Localizable", "WhatsNew.title")
    /// Version %@
    internal static func version(_ p1: Any) -> String {
      return L10n.tr("Localizable", "WhatsNew.version", String(describing: p1))
    }
    internal enum _110 {
      /// New Brazilian Protuguese translation 🇧🇷!\nAnd new syntax highlight on the code examples.
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_1_0.description")
    }
    internal enum _120 {
      /// New Gestures and Dynamic font guides.
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_2_0.description")
    }
    internal enum _130 {
      /// New Puzzles!\nNew reduce motion guide.\nAnd a new dynamic font page about how to identify the preferred font size.
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_3_0.description")
    }
    internal enum _140 {
      /// New Dark mode guide!
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_4_0.description")
    }
    internal enum _150 {
      /// New visual aid section on the 'Others Features'\nNew image accessibility trait page.
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_5_0.description")
    }
    internal enum _160 {
      /// New 'What's new on the app' page to help users find new content they have not yet seen.\nSearch improvements, now the search content is alphabetically sorted with the respective section icon on each page.\nNew share and deeplinking capability on the app - now you can share every page with anyone and they can open them using the direct link!\nAnd new accessibility trait pages.
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_6_0.description")
    }
    internal enum _170 {
      /// New Home Screen layout for iPads and iPhones in landscape! Now we are using better the available size on the screen for both formats.\nAnd a brand new Rotor example page where you can try using custom rotors for yourself.
      internal static let description = L10n.tr("Localizable", "WhatsNew.1_7_0.description")
    }
  }

  internal enum WhereIsMyContent {
    /// This puzzle is pretty easy.
    internal static let text1 = L10n.tr("Localizable", "WhereIsMyContent.text1")
    /// You need to find the correct button to finish the puzzle by using VoiceOver!
    internal static let text2 = L10n.tr("Localizable", "WhereIsMyContent.text2")
    /// Where is my content?
    internal static let title = L10n.tr("Localizable", "WhereIsMyContent.title")
  }
}
// swiftlint:enable explicit_type_interface function_parameter_count identifier_name line_length
// swiftlint:enable nesting type_body_length type_name vertical_whitespace_opening_braces

// MARK: - Implementation Details

extension L10n {
  private static func tr(_ table: String, _ key: String, _ args: CVarArg...) -> String {
    let format = BundleToken.bundle.localizedString(forKey: key, value: nil, table: table)
    return String(format: format, locale: Locale.current, arguments: args)
  }
}

// swiftlint:disable convenience_type
private final class BundleToken {
  static let bundle: Bundle = {
    #if SWIFT_PACKAGE
    return Bundle.module
    #else
    return Bundle(for: BundleToken.self)
    #endif
  }()
}
// swiftlint:enable convenience_type
